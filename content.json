{"meta":{"title":"ZigZagK的博客","subtitle":"Never give up fighting!","description":null,"author":"ZigZagK","url":"https://zigzagk.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-25T07:51:30.887Z","updated":"2019-07-25T07:51:30.887Z","comments":false,"path":"404.html","permalink":"https://zigzagk.github.io/404.html","excerpt":"","text":"你到底是怎么进来的？算了不关我事QAQ…… 404页面是客户端在浏览网页时，服务器无法正常提供信息，或是服务器无法回应，且不知道原因所返回的页面。据说在第三次科技革命之前，互联网的形态就是一个大型的中央数据库，这个数据库就设置在404房间里面。那时候所有的请求都是由人工手动完成的，如果在数据库中没有找到请求者所需要的文件，或者由于请求者写错了文件编号，用户就会得到一个返回信息：room 404 : file not found。404错误信息通常是在目标页面被更改或移除，或客户端输入页面地址错误后显示的页面，人们也就习惯了用404作为服务器未找到文件的错误代码了。当然实际考证传说中的room 404是不存在的，在http请求3位的返回码中，4开头的代表客户错误，5开头代表服务器端错误。 …… 当用户不小心访问了某一个不存在的页面并且没有设置错误提示 时，用户会怎么做？如果是初次到访的访客，那么回头率是多少呢？毫无疑问，会抱怨为何出现错误，之后当然是直接关闭窗口离开。所以设置了 404页面也相当于是做了一个针对用户的提示页面，当用户访问了某一个 不存在的页面后就会转到404页面，然后因为你在这个404页面上有友好 的提示，并且有首页和主要栏目页的连接，用户就很有可能会再次点击进入你的首页。但是，Web服务器默认的404错误页面，无论是Apache还是IIS，均十分简陋、呆板且对用户不友好，无法给用户提供必要的信息以获取更 多线索，无疑这会造成用户的流失。 因此，很多网站均使用自定义404错误的方式提供用户体验避免用户流失。一般而言，自定义404页面通用的做法是在页面中放置网站快速导航链接、搜索框以及网页提供的特色服务，这样可以有效的帮助用户访问站点并获取需要的信息。 百度百科 —— 404页面 在404页面划水也是不错的体验呢QwQ。"},{"title":"关于我","date":"2019-07-25T05:34:28.000Z","updated":"2019-07-25T06:01:13.804Z","comments":true,"path":"about/index.html","permalink":"https://zigzagk.github.io/about/index.html","excerpt":"","text":"Typecho博客：https://zigzagk.top。 闲来无事又建了Hexo博客玩。 采用了indigo主题，一直很喜欢这个主题，MDUI2333有很多这个主题的身影。 其实我还不知道这个博客拿来干嘛……"},{"title":"categories","date":"2019-07-25T04:54:14.000Z","updated":"2019-07-25T04:56:09.350Z","comments":false,"path":"categories/index.html","permalink":"https://zigzagk.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-25T04:54:08.000Z","updated":"2019-07-25T04:55:57.658Z","comments":false,"path":"tags/index.html","permalink":"https://zigzagk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"机房大佬语录API","slug":"APIForQEOI","date":"2019-08-01T07:31:18.000Z","updated":"2019-08-01T07:40:12.242Z","comments":true,"path":"2019/08/01/APIForQEOI/","link":"","permalink":"https://zigzagk.github.io/2019/08/01/APIForQEOI/","excerpt":"","text":"搭了个API，闲来无事，就做了个我校机房大佬语录，效果类似一言。 调用方式： Json 访问https://api.zigzagk.top/?s=OrzHL.dictum。 示例输出： 12345&#123; \"id\":11, \"text\":\"闪总曰：分治啊，看个毛线。\", \"from\":\"XZY\"&#125; Html 访问https://api.zigzagk.top/?s=OrzHL.dictum&amp;encode=HTML。 示例输出：闪总曰：这题只要花点时间，太烦了。 Js（推荐使用） 访问https://api.zigzagk.top/?s=OrzHL.dictum&amp;encode=js。 把下面这段代码插入任意位置，将自动替换为语录： 1&lt;script src=\"https://api.zigzagk.top/?s=OrzHL.dictum&amp;encode=js\"&gt;&lt;/script&gt;&lt;script&gt;OrzHL();&lt;/script&gt; 效果可以参考本Blog的底部QwQ。 水文真开心。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zigzagk.github.io/categories/PHP/"},{"name":"API","slug":"PHP/API","permalink":"https://zigzagk.github.io/categories/PHP/API/"}],"tags":[{"name":"API","slug":"API","permalink":"https://zigzagk.github.io/tags/API/"}]},{"title":"Typecho新博客","slug":"Typechonewblog","date":"2019-07-25T07:14:00.000Z","updated":"2019-07-25T07:15:34.436Z","comments":true,"path":"2019/07/25/Typechonewblog/","link":"","permalink":"https://zigzagk.github.io/2019/07/25/Typechonewblog/","excerpt":"","text":"博主的Typecho博客，欢迎来玩~~~ 这个Hexo博客暂时还不知道拿来干啥……","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}],"author":"ZigZagK"},{"title":"Hexo用Leancloud实现阅读量和评论数的统计与排序","slug":"HexoLeancloud","date":"2018-04-21T08:44:00.000Z","updated":"2019-07-25T08:00:46.302Z","comments":true,"path":"2018/04/21/HexoLeancloud/","link":"","permalink":"https://zigzagk.github.io/2018/04/21/HexoLeancloud/","excerpt":"","text":"自我感觉Leancloud非常好用啊XD！ 阅读量统计 Hexo想实现博客阅读量统计需要借助统计网站，Leancloud是比较不错的选择。 在你的应用里创建名为\"Counter\"的Class，注意权限要给成无限制（所以一定要设置Web安全域名！）。 以yilia为例，在after-footer.ejs里添加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script src=\"&lt;%- theme.js_cdn.jquery %&gt;\"&gt;&lt;/script&gt;&lt;script src=\"&lt;%- theme.js_cdn.av %&gt;\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; if(&lt;%- theme.leancloud_visitors.enable %&gt;)&#123; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: leancloud_app_id, appKey: leancloud_app_key &#125;); var pageViewsLength = $(\".pageViews\").length; var isIndex = $(\"#page-nav\").length &gt; 0 ?true:false; function showTime() &#123; var Counter = AV.Object.extend(\"Counter\"); if(isIndex)&#123; $(\".pageViews\").each(function()&#123; showPageViewsNum($(this),Counter); &#125;); &#125;else&#123; addPageViewsNum($(\".pageViews\")); showPageViewsNum($(\".pageViews\"),Counter); &#125; &#125; function showPageViewsNum(ele,Counter)&#123; var query = new AV.Query(\"Counter\"); var url = ele.attr('id').trim(); query.equalTo(\"words\",url); query.find().then(function(results)&#123; if (results.length&gt;0) $(document.getElementById(url)).text(results[0].get(\"views\")); else $(document.getElementById(url)).text('0'); &#125;,function(error)&#123;$(document.getElementById(url)).text('0');&#125;); &#125; function addPageViewsNum(ele)&#123; var url = ele.attr('id').trim();var title = $('.article-title').text().trim(); var Counter = AV.Object.extend(\"Counter\"); var now=new AV.Query(Counter);now.equalTo(\"words\",url); now.find().then(function(results)&#123; if (results.length&gt;0)&#123; var query=results[0]; query.increment(\"views\"); query.fetchWhenSave(true); query.save(); &#125; else&#123; var query = new Counter; query.set(\"words\",url); query.set(\"title\",title); query.set(\"views\",1); query.save(null,&#123;&#125;).then(function (object) &#123;&#125;); &#125; &#125;,function(error)&#123;&#125;); &#125; if(pageViewsLength)&#123; showTime(); &#125;&#125;&lt;/script&gt; 差不多就是检查这篇文章有没有被访问过，有的话直接更新原来的信息，将views加一，否则创建新的信息。 显示阅读量的话，根据你提供的url来获取到对应的信息，得到views，然后用js更改网页上的指定位置。在article.ejs的合适位置添加： 1&lt;span id=\"&lt;%- url_for(post.path) %&gt;\" class=\"pageViews\"&gt;X&lt;/span&gt; 当然，还需要在_config.yml里添加： 12345678leancloud_visitors: enable: true app_id: 你的ID app_key: 你的KEYjs_cdn: jquery: https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js av : //cdn1.lncld.net/static/js/2.5.0/av-min.js 题外话：原先阅读量采用的是一次加一条信息的方法，但是直到星期四学弟们集体写vbs“攻击”了我的博客……上千条信息我TM根本没法删……现在这种方法就可以直接改views，相对来说方便很多。 阅读量排行 因为信息中存了views，而且Leancloud自带很多有用的操作，所以我们可以实现阅读量排行！ 首先在你想显示的地方加上&lt;ul class=\"HotArticle\"&gt;&lt;/ul&gt;用来得到排行列表，class可以随便给（但是最好不要和其他class一样，不然可能会出锅QAQ）。 然后在after-footer.ejs里添加： 1234567891011121314151617181920&lt;script type=\"text/javascript\"&gt; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: lealeancloud_app_keyncloud_app_id, appKey: leancloud_app_key &#125;); var Counter=AV.Object.extend(\"Counter\");var query=new AV.Query(Counter); query.descending(\"views\");query.limit(10); query.find().then(function(results)&#123; for(var i=0;i&lt;results.length;i++)&#123; var counter=results[i]; var title=counter.get(\"title\"); var url=counter.get(\"words\"); var views=counter.get(\"views\"); $('.HotArticle').append('&lt;li&gt;&lt;a href=\"'+url+'\"&gt;'+title+'&lt;/a&gt;&lt;span&gt;'+views+'&lt;/span&gt;&lt;/li&gt;'); //$('.class')中的class一定要和上面的class一样 &#125; &#125;,function(error)&#123;&#125;);&lt;/script&gt; 不难看出这就是调用了Leancloud自带的排序，然后输出到排行列表里。最后改一下排行列表的样式就行了~~~ 评论数统计 Emm……这个有些复杂，但并不是很难实现。 首先你要使用Valine评论系统，是借助Leancloud实现的，跟着链接里说的做就行了。 题外话：Valine要实现邮箱提醒功能，一定要使用链接里Dalao给出的Valine.min.js（或者你可以自己写）。 随便发几条评论，到Leancloud里查看，会发现储存下来的信息中有一个url记录了文章链接，用这个就可以搞事情了！ 在after-footer.ejs里添加： 1234567891011121314151617181920212223242526272829303132333435&lt;script type=\"text/javascript\"&gt; if(&lt;%- theme.leancloud_visitors.enable %&gt;)&#123; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: leancloud_app_id, appKey: leancloud_app_key &#125;); var commentCountLength = $(\".commentCount\").length; var isIndex = $(\".commentCount\").length &gt; 1 ?true:false; function showCount() &#123; var Comment = AV.Object.extend(\"Comment\"); if(isIndex)&#123; $(\".commentCount\").each(function()&#123; showcommentCountNum($(this),Comment); &#125;); &#125;else&#123; showcommentCountNum($(\".commentCount\"),Comment); &#125; &#125; function showcommentCountNum(ele,Comment)&#123; var query = new AV.Query(\"Comment\"); var key = ele.attr('id').trim();var url = key.substring(0,key.length-12); query.equalTo(\"url\", url); query.count().then(function (number) &#123; $(document.getElementById(key)).text(number? number : '0'); &#125;, function (error) &#123; $(document.getElementById(key)).text('0'); &#125;); &#125; if(commentCountLength)&#123; showCount(); &#125;&#125;&lt;/script&gt; 代码可能有些奇怪，不要在意QAQ。原理差不多就是统计出信息中url为当前文章链接的信息数量。 在article.ejs的合适位置添加： 1&lt;span id=\"&lt;%- url_for(post.path) %&gt;commentCount\" class=\"commentCount\"&gt;X&lt;/span&gt; 最近评论 和阅读量排行差不多啦，每条信息都会有个创建时间createdAt，按照这个排序之后取前若干个就行了。 先在要显示的地方添加&lt;ul class=\"LatestComment\"&gt;&lt;/ul&gt;，然后在after-footer.ejs中添加： 12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: leancloud_app_id, appKey: leancloud_app_key &#125;); var Comment=AV.Object.extend(\"Comment\"); var query=new AV.Query(Comment); query.descending(\"createdAt\");query.limit(5); query.find().then(function(results)&#123; for(var i=0;i&lt;results.length;i++)&#123; var comment=results[i]; var nick=comment.get(\"nick\"); var link=comment.get(\"link\"); var url=comment.get(\"url\"); var words=comment.get(\"comment\"); var time=comment.get(\"createdAt\").toLocaleString(); $('.LatestComment').append('&lt;li&gt;&lt;a href=\"'+link+'\"&gt;'+nick+'&lt;/a&gt;在&lt;a href=\"'+url+'#lv-container\"&gt;'+time+'&lt;/a&gt;发表：&lt;br&gt;&lt;div&gt;'+words+'&lt;/div&gt;&lt;/a&gt;&lt;/li&gt;'); &#125; &#125;,function(error)&#123;&#125;);&lt;/script&gt; 效果 阅读量和评论数统计： 阅读排行和最近评论： 参考 看了添加 hexo yilia 主题的文章阅读量和使用LeanCloud平台为Hexo博客添加文章浏览量统计组件的代码之后魔改出了自己的代码XD。 Valine评论系统 Valine: 独立博客评论系统","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"},{"name":"Hexo","slug":"杂/Hexo","permalink":"https://zigzagk.github.io/categories/杂/Hexo/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}],"author":"ZigZagK"},{"title":"欢迎来到ZigZagK的博客！","slug":"ZigZagKBlog","date":"2018-02-24T07:26:00.000Z","updated":"2019-07-25T08:01:20.586Z","comments":true,"path":"2018/02/24/ZigZagKBlog/","link":"","permalink":"https://zigzagk.github.io/2018/02/24/ZigZagKBlog/","excerpt":"","text":"博主是个蒟蒻！谢谢Dalao们捧场！ 是时候丢弃CSDN了。——By Lynstery 其实我也是被CSDN气过来的。 \\(\\LaTeX\\) :我们来求个 \\(LIS\\) 吧 \\(f(i)=max\\{f(j)|j&lt;i,a_j&lt;a_i\\}+1\\) \\[ 我有一个数组\\{A_n\\}\\\\ A_1,A_2,A_3,A_4,A_5,A_6,A_7,\\cdots,A_n\\\\ A_i的平方是A_i^2,A_i开根号是\\sqrt{A_i} \\] 话说，如果每次换电脑都要重装Hexo什么的，好像很烦啊。 1int main() &#123;return 0;&#125; 人名 OI水平 文化课水平 ZigZagK \\(-\\infty\\) \\(-\\infty\\) Lynstery \\(+\\infty\\) \\(+\\infty\\) 这是我CSDN的博客链接。 我的Logo:","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"},{"name":"Hexo","slug":"杂/Hexo","permalink":"https://zigzagk.github.io/categories/杂/Hexo/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}]}]}