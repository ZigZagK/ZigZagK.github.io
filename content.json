{"meta":{"title":"ZigZagK的博客","subtitle":"Never give up fighting!","description":null,"author":"ZigZagK","url":"https://zigzagk.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-07-25T07:51:30.887Z","updated":"2019-07-25T07:51:30.887Z","comments":false,"path":"404.html","permalink":"https://zigzagk.github.io/404.html","excerpt":"","text":"你到底是怎么进来的？算了不关我事QAQ…… 404页面是客户端在浏览网页时，服务器无法正常提供信息，或是服务器无法回应，且不知道原因所返回的页面。据说在第三次科技革命之前，互联网的形态就是一个大型的中央数据库，这个数据库就设置在404房间里面。那时候所有的请求都是由人工手动完成的，如果在数据库中没有找到请求者所需要的文件，或者由于请求者写错了文件编号，用户就会得到一个返回信息：room 404 : file not found。404错误信息通常是在目标页面被更改或移除，或客户端输入页面地址错误后显示的页面，人们也就习惯了用404作为服务器未找到文件的错误代码了。当然实际考证传说中的room 404是不存在的，在http请求3位的返回码中，4开头的代表客户错误，5开头代表服务器端错误。 …… 当用户不小心访问了某一个不存在的页面并且没有设置错误提示 时，用户会怎么做？如果是初次到访的访客，那么回头率是多少呢？毫无疑问，会抱怨为何出现错误，之后当然是直接关闭窗口离开。所以设置了 404页面也相当于是做了一个针对用户的提示页面，当用户访问了某一个 不存在的页面后就会转到404页面，然后因为你在这个404页面上有友好 的提示，并且有首页和主要栏目页的连接，用户就很有可能会再次点击进入你的首页。但是，Web服务器默认的404错误页面，无论是Apache还是IIS，均十分简陋、呆板且对用户不友好，无法给用户提供必要的信息以获取更 多线索，无疑这会造成用户的流失。 因此，很多网站均使用自定义404错误的方式提供用户体验避免用户流失。一般而言，自定义404页面通用的做法是在页面中放置网站快速导航链接、搜索框以及网页提供的特色服务，这样可以有效的帮助用户访问站点并获取需要的信息。 百度百科 —— 404页面 在404页面划水也是不错的体验呢QwQ。"},{"title":"关于我","date":"2019-07-25T05:34:28.000Z","updated":"2019-07-25T06:01:13.804Z","comments":true,"path":"about/index.html","permalink":"https://zigzagk.github.io/about/index.html","excerpt":"","text":"Typecho博客：https://zigzagk.top。 闲来无事又建了Hexo博客玩。 采用了indigo主题，一直很喜欢这个主题，MDUI2333有很多这个主题的身影。 其实我还不知道这个博客拿来干嘛……"},{"title":"categories","date":"2019-07-25T04:54:14.000Z","updated":"2019-07-25T04:56:09.350Z","comments":false,"path":"categories/index.html","permalink":"https://zigzagk.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-25T04:54:08.000Z","updated":"2019-07-25T04:55:57.658Z","comments":false,"path":"tags/index.html","permalink":"https://zigzagk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Typecho新博客","slug":"Typechonewblog","date":"2019-07-25T07:14:00.000Z","updated":"2019-07-25T07:15:34.436Z","comments":true,"path":"2019/07/25/Typechonewblog/","link":"","permalink":"https://zigzagk.github.io/2019/07/25/Typechonewblog/","excerpt":"","text":"博主的Typecho博客，欢迎来玩~~~ 这个Hexo博客暂时还不知道拿来干啥……","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}],"author":"ZigZagK"},{"title":"ZJOI2018爆炸记","slug":"ZJOI2018AFO","date":"2018-04-26T10:27:00.000Z","updated":"2019-07-25T05:49:02.527Z","comments":true,"path":"2018/04/26/ZJOI2018AFO/","link":"","permalink":"https://zigzagk.github.io/2018/04/26/ZJOI2018AFO/","excerpt":"看来我和去年相比完全没有什么长进Orz。","text":"看来我和去年相比完全没有什么长进Orz。 Day1 一试放在本校日神仙，Manchery学长演讲好评。听课的时候发现自己和去年比好像没有什么长进。 Day1点开试卷发现自己跟去年就是完全没有什么长进。T1写了大众分，T2写了大众分，T3爆零被巨佬们甩开一大截。 20+10+0=30。Day1爆炸预退役。 Day2 二试又在余姚日神仙，mjy学姐讲课好评。听课的时候发现自己马上就要退役了。 第二天下午是高校宣传，我神志不清留下了，简陋地记了一下招生条件发现自己没书读了。 Day2点开试卷发现自己真的就是要退役了。T1写了阶乘爆枚，T2写了白痴暴力，T3全世界都写了 \\(n=3\\) 的特判就我输出了一个 \\(0\\) 。 20+20+0=40。Day2爆炸退役苟文化课。 附录 浙大：NOI铜牌以上降一本，NOIP1= \\(\\to\\) 自主招生。(我没戏) 浙工大：NOIP2= \\(\\to\\) 面试，5A+其他C及以上+NOIP3 or 8A+其他C及以上= \\(\\to\\) 自主招生？三位一体？（没听清楚）。（我也没戏） 杭电：HDU很棒棒&amp;革命友谊&amp;革命友谊的升华(LOVE)NOIP3= \\(\\to\\) 免笔试。（我还没戏） 浙大城市学院(?)：可以咸鱼(我)翻身(不可能)转入浙大(??)。（我仍没戏） 国科大：自主招生优先考虑(???)。（我就没戏） 清华大学：竞赛成绩好+文化课成绩不差。（我真没戏） 北京大学：竞赛成绩好+文化课成绩不差。（我全没戏）","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"},{"name":"游记","slug":"杂/游记","permalink":"https://zigzagk.github.io/categories/杂/游记/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}],"author":"ZigZagK"},{"title":"[折半搜索]TopCoder【EllysRPS】题解","slug":"TopCoderEllysRPS","date":"2018-04-24T08:52:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/24/TopCoderEllysRPS/","link":"","permalink":"https://zigzagk.github.io/2018/04/24/TopCoderEllysRPS/","excerpt":"题目概述 你要跟一共 \\(m\\) 个人玩剪刀石头布的游戏，其中 R(Rock) 胜 S(Scissors)、S(Scissors) 胜 P(Paper)、P(Paper) 胜 R(Rock)。如果出同样的算平局。你与一个人共玩 \\(n\\) 局，胜的 局数多的人胜出，如果胜的局数相同就打成平手。你现在知道了这 \\(m\\) 个人在每局分别会出什么，你想要确定一个出拳的序列，使得在与 这 \\(m\\) 个人的游戏中都能打成平手。输出满足条件的序列数。","text":"题目概述 你要跟一共 \\(m\\) 个人玩剪刀石头布的游戏，其中 R(Rock) 胜 S(Scissors)、S(Scissors) 胜 P(Paper)、P(Paper) 胜 R(Rock)。如果出同样的算平局。你与一个人共玩 \\(n\\) 局，胜的 局数多的人胜出，如果胜的局数相同就打成平手。你现在知道了这 \\(m\\) 个人在每局分别会出什么，你想要确定一个出拳的序列，使得在与 这 \\(m\\) 个人的游戏中都能打成平手。输出满足条件的序列数。 解题报告 \\(O(3^{n}m)\\) 会炸掉，然后我们就会发现折半搜索就行了……效率 \\(O(3^{n\\over 2}m)\\) 。 示例程序 123456789101112131415161718192021222324252627#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=20,maxm=100;const int fl[3][3]=&#123;&#123;0,-1,1&#125;,&#123;1,0,-1&#125;,&#123;-1,1,0&#125;&#125;;//0 R|1 P|2 Sclass EllysRPS&#123; vector&lt;string&gt; a;int n,m;LL ans;int ID[256]; vector&lt;int&gt; now;map&lt;vector&lt;int&gt;,int&gt; ha; void Dfs(int L,int R,int f)&#123; if (L&gt;R) &#123;f&gt;0?ha[now]++:ans+=(LL)ha[now];return;&#125; for (int i=0;i&lt;3;i++)&#123; for (int j=0;j&lt;m;j++) now[j]+=f*fl[i][ID[(int)a[j][L]]]; Dfs(L+1,R,f); for (int j=0;j&lt;m;j++) now[j]-=f*fl[i][ID[(int)a[j][L]]]; &#125; &#125;public: LL getCount(vector&lt;string&gt; s)&#123; a=s;m=a.size();n=a[0].length();ID[(int)'R']=0;ID[(int)'P']=1;ID[(int)'S']=2; ans=0;now.resize(m);Dfs(0,n/2-1,1);Dfs(n/2,n-1,-1);return ans; &#125;&#125;;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"TopCoder","slug":"Online-Judge/TopCoder","permalink":"https://zigzagk.github.io/categories/Online-Judge/TopCoder/"}],"tags":[{"name":"折半搜索","slug":"折半搜索","permalink":"https://zigzagk.github.io/tags/折半搜索/"}],"author":"ZigZagK"},{"title":"Hexo用Leancloud实现阅读量和评论数的统计与排序","slug":"HexoLeancloud","date":"2018-04-21T08:44:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/21/HexoLeancloud/","link":"","permalink":"https://zigzagk.github.io/2018/04/21/HexoLeancloud/","excerpt":"自我感觉Leancloud非常好用啊XD！","text":"自我感觉Leancloud非常好用啊XD！ 阅读量统计 Hexo想实现博客阅读量统计需要借助统计网站，Leancloud是比较不错的选择。 在你的应用里创建名为\"Counter\"的Class，注意权限要给成无限制（所以一定要设置Web安全域名！）。 以yilia为例，在after-footer.ejs里添加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script src=\"&lt;%- theme.js_cdn.jquery %&gt;\"&gt;&lt;/script&gt;&lt;script src=\"&lt;%- theme.js_cdn.av %&gt;\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; if(&lt;%- theme.leancloud_visitors.enable %&gt;)&#123; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: leancloud_app_id, appKey: leancloud_app_key &#125;); var pageViewsLength = $(\".pageViews\").length; var isIndex = $(\"#page-nav\").length &gt; 0 ?true:false; function showTime() &#123; var Counter = AV.Object.extend(\"Counter\"); if(isIndex)&#123; $(\".pageViews\").each(function()&#123; showPageViewsNum($(this),Counter); &#125;); &#125;else&#123; addPageViewsNum($(\".pageViews\")); showPageViewsNum($(\".pageViews\"),Counter); &#125; &#125; function showPageViewsNum(ele,Counter)&#123; var query = new AV.Query(\"Counter\"); var url = ele.attr('id').trim(); query.equalTo(\"words\",url); query.find().then(function(results)&#123; if (results.length&gt;0) $(document.getElementById(url)).text(results[0].get(\"views\")); else $(document.getElementById(url)).text('0'); &#125;,function(error)&#123;$(document.getElementById(url)).text('0');&#125;); &#125; function addPageViewsNum(ele)&#123; var url = ele.attr('id').trim();var title = $('.article-title').text().trim(); var Counter = AV.Object.extend(\"Counter\"); var now=new AV.Query(Counter);now.equalTo(\"words\",url); now.find().then(function(results)&#123; if (results.length&gt;0)&#123; var query=results[0]; query.increment(\"views\"); query.fetchWhenSave(true); query.save(); &#125; else&#123; var query = new Counter; query.set(\"words\",url); query.set(\"title\",title); query.set(\"views\",1); query.save(null,&#123;&#125;).then(function (object) &#123;&#125;); &#125; &#125;,function(error)&#123;&#125;); &#125; if(pageViewsLength)&#123; showTime(); &#125;&#125;&lt;/script&gt; 差不多就是检查这篇文章有没有被访问过，有的话直接更新原来的信息，将views加一，否则创建新的信息。 显示阅读量的话，根据你提供的url来获取到对应的信息，得到views，然后用js更改网页上的指定位置。在article.ejs的合适位置添加： 1&lt;span id=\"&lt;%- url_for(post.path) %&gt;\" class=\"pageViews\"&gt;X&lt;/span&gt; 当然，还需要在_config.yml里添加： 12345678leancloud_visitors: enable: true app_id: 你的ID app_key: 你的KEYjs_cdn: jquery: https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js av : //cdn1.lncld.net/static/js/2.5.0/av-min.js 题外话：原先阅读量采用的是一次加一条信息的方法，但是直到星期四学弟们集体写vbs“攻击”了我的博客……上千条信息我TM根本没法删……现在这种方法就可以直接改views，相对来说方便很多。 阅读量排行 因为信息中存了views，而且Leancloud自带很多有用的操作，所以我们可以实现阅读量排行！ 首先在你想显示的地方加上&lt;ul class=\"HotArticle\"&gt;&lt;/ul&gt;用来得到排行列表，class可以随便给（但是最好不要和其他class一样，不然可能会出锅QAQ）。 然后在after-footer.ejs里添加： 1234567891011121314151617181920&lt;script type=\"text/javascript\"&gt; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: lealeancloud_app_keyncloud_app_id, appKey: leancloud_app_key &#125;); var Counter=AV.Object.extend(\"Counter\");var query=new AV.Query(Counter); query.descending(\"views\");query.limit(10); query.find().then(function(results)&#123; for(var i=0;i&lt;results.length;i++)&#123; var counter=results[i]; var title=counter.get(\"title\"); var url=counter.get(\"words\"); var views=counter.get(\"views\"); $('.HotArticle').append('&lt;li&gt;&lt;a href=\"'+url+'\"&gt;'+title+'&lt;/a&gt;&lt;span&gt;'+views+'&lt;/span&gt;&lt;/li&gt;'); //$('.class')中的class一定要和上面的class一样 &#125; &#125;,function(error)&#123;&#125;);&lt;/script&gt; 不难看出这就是调用了Leancloud自带的排序，然后输出到排行列表里。最后改一下排行列表的样式就行了~~~ 评论数统计 Emm……这个有些复杂，但并不是很难实现。 首先你要使用Valine评论系统，是借助Leancloud实现的，跟着链接里说的做就行了。 题外话：Valine要实现邮箱提醒功能，一定要使用链接里Dalao给出的Valine.min.js（或者你可以自己写）。 随便发几条评论，到Leancloud里查看，会发现储存下来的信息中有一个url记录了文章链接，用这个就可以搞事情了！ 在after-footer.ejs里添加： 1234567891011121314151617181920212223242526272829303132333435&lt;script type=\"text/javascript\"&gt; if(&lt;%- theme.leancloud_visitors.enable %&gt;)&#123; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: leancloud_app_id, appKey: leancloud_app_key &#125;); var commentCountLength = $(\".commentCount\").length; var isIndex = $(\".commentCount\").length &gt; 1 ?true:false; function showCount() &#123; var Comment = AV.Object.extend(\"Comment\"); if(isIndex)&#123; $(\".commentCount\").each(function()&#123; showcommentCountNum($(this),Comment); &#125;); &#125;else&#123; showcommentCountNum($(\".commentCount\"),Comment); &#125; &#125; function showcommentCountNum(ele,Comment)&#123; var query = new AV.Query(\"Comment\"); var key = ele.attr('id').trim();var url = key.substring(0,key.length-12); query.equalTo(\"url\", url); query.count().then(function (number) &#123; $(document.getElementById(key)).text(number? number : '0'); &#125;, function (error) &#123; $(document.getElementById(key)).text('0'); &#125;); &#125; if(commentCountLength)&#123; showCount(); &#125;&#125;&lt;/script&gt; 代码可能有些奇怪，不要在意QAQ。原理差不多就是统计出信息中url为当前文章链接的信息数量。 在article.ejs的合适位置添加： 1&lt;span id=\"&lt;%- url_for(post.path) %&gt;commentCount\" class=\"commentCount\"&gt;X&lt;/span&gt; 最近评论 和阅读量排行差不多啦，每条信息都会有个创建时间createdAt，按照这个排序之后取前若干个就行了。 先在要显示的地方添加&lt;ul class=\"LatestComment\"&gt;&lt;/ul&gt;，然后在after-footer.ejs中添加： 12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; var leancloud_app_id = '&lt;%- theme.leancloud_visitors.app_id %&gt;'; var leancloud_app_key = '&lt;%- theme.leancloud_visitors.app_key %&gt;'; AV.init(&#123; appId: leancloud_app_id, appKey: leancloud_app_key &#125;); var Comment=AV.Object.extend(\"Comment\"); var query=new AV.Query(Comment); query.descending(\"createdAt\");query.limit(5); query.find().then(function(results)&#123; for(var i=0;i&lt;results.length;i++)&#123; var comment=results[i]; var nick=comment.get(\"nick\"); var link=comment.get(\"link\"); var url=comment.get(\"url\"); var words=comment.get(\"comment\"); var time=comment.get(\"createdAt\").toLocaleString(); $('.LatestComment').append('&lt;li&gt;&lt;a href=\"'+link+'\"&gt;'+nick+'&lt;/a&gt;在&lt;a href=\"'+url+'#lv-container\"&gt;'+time+'&lt;/a&gt;发表：&lt;br&gt;&lt;div&gt;'+words+'&lt;/div&gt;&lt;/a&gt;&lt;/li&gt;'); &#125; &#125;,function(error)&#123;&#125;);&lt;/script&gt; 效果 阅读量和评论数统计： 阅读排行和最近评论： 参考 看了添加 hexo yilia 主题的文章阅读量和使用LeanCloud平台为Hexo博客添加文章浏览量统计组件的代码之后魔改出了自己的代码XD。 Valine评论系统 Valine: 独立博客评论系统","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"},{"name":"Hexo","slug":"杂/Hexo","permalink":"https://zigzagk.github.io/categories/杂/Hexo/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}],"author":"ZigZagK"},{"title":"[二分+上下界费用流]HDU5263【平衡大师】题解","slug":"HDU5263","date":"2018-04-19T08:03:00.000Z","updated":"2019-07-25T06:33:40.890Z","comments":true,"path":"2018/04/19/HDU5263/","link":"","permalink":"https://zigzagk.github.io/2018/04/19/HDU5263/","excerpt":"题目概述 有 \\(n\\) 个点 \\(m\\) 条单向边，每个点的不平衡度为出度减入度的差的绝对值，现在可以删除至多 \\(m-K\\) 条边，求最大不平衡度的最小值。","text":"题目概述 有 \\(n\\) 个点 \\(m\\) 条单向边，每个点的不平衡度为出度减入度的差的绝对值，现在可以删除至多 \\(m-K\\) 条边，求最大不平衡度的最小值。 解题报告 其实不难吧……只是水平限制了我的想象力……首先二分答案 \\(D\\) ，令 \\(d_i\\) 表示 \\(i\\) 点的入度 \\(-\\) 出度，对于一条单向边 \\((x,y)\\) 我们连 \\(x\\to y\\) 上界为 \\(1\\) 的边，如果 \\((x,y)\\) 满载说明这条边被删。然后对于 \\(d_i\\) 分类讨论一下： \\(d_i\\ge D\\) ，那么至少要减掉 \\(d_i-D\\) 的出度，所以连 \\(i\\to T\\) 下界为 \\(d_i-D\\) 的边，但是又不能减爆，所以上界为 \\(d_i+D\\) 。 \\(-D&lt;d_i&lt;D\\) ，可加可减，连 \\(S\\to i\\) 上界为 \\(D-d_i\\) ，连 \\(i\\to T\\) 上界为 \\(d_i+D\\) 的边。 \\(d_i\\le -D\\) ，连 \\(S\\to i\\) 下界为 \\(-D-d_i\\) ，上界为 \\(D-d_i\\) 的边。 原本我以为直接刷上下界最小流就行了，然后疯狂WA，之后发现这样会出现一种违规的情况： 你看下面那种 \\(x\\) 通过 \\(y\\) 间接向 \\(z\\) 提供流了啊，这并不符合我们的要求啊QAQ！！！ 所以我们再引入费用，对于单向边 \\((x,y)\\) 连上界为 \\(1\\) 费用为 \\(1\\) 的边，其他边的费用为 \\(0\\) 。这样的话显然会采取上面那种方法，从而防止下面错误的方法出现。 上下界费用流？我不会啊！其实就和上下界网络流一样……只不过换成了费用流…… 示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;#define fr first#define sc second#define mp make_pairusing namespace std;const int maxn=52,maxm=maxn*maxn,maxe=(maxm+2*maxn)&lt;&lt;1,INF=2e9;int te,n,S,T,SS,TT,m,K,x[maxm+5],y[maxm+5],d[maxn+5],num[maxn+5];int E,lnk[maxn+5],son[maxe+5],nxt[maxe+5],w[maxe+5];int que[maxn+5],ti,vis[maxn+5],dis[maxn+5],MIN[maxn+5];pair&lt;int,int&gt; e[maxe+5];map&lt;string,int&gt; ID;inline void Add(int x,int y,int L,int R,int c)&#123; son[E]=y;w[E]=c;e[E]=mp(0,R-L);nxt[E]=lnk[x];lnk[x]=E++; son[E]=x;w[E]=-c;e[E]=mp(0,0);nxt[E]=lnk[y];lnk[y]=E++; num[x]-=L;num[y]+=L;&#125;#define AM(x) ((x)&lt;maxn?((x)+1):0)inline bool Spfa(int s,int t,int &amp;MC,int &amp;MF)&#123; static int fa[maxn+5],pre[maxn+5];memset(dis,63,sizeof(dis));MIN[t]=INF; int Head=0,Tail=0;que[++Tail]=s;vis[s]=++ti;dis[s]=0;MIN[s]=INF; while (Head!=Tail)&#123; int x=que[Head=AM(Head)];vis[x]=0; for (int j=lnk[x],u;~j;j=nxt[j]) if (e[j].fr&lt;e[j].sc&amp;&amp;dis[x]+w[j]&lt;dis[u=son[j]])&#123; dis[u]=dis[x]+w[j];MIN[u]=min(MIN[x],e[j].sc-e[j].fr); fa[u]=x;pre[u]=j;if (vis[u]&lt;ti) que[Tail=AM(Tail)]=u,vis[u]=ti; &#125; &#125; if (MIN[t]==INF) return false; for (int x=t,j=pre[x];x!=s;x=fa[x],j=pre[x]) e[j].fr+=MIN[t],e[j^1].fr-=MIN[t]; return MC+=dis[t]*MIN[t],MF+=MIN[t],true;&#125;inline int MCMF(int s,int t,int &amp;MC) &#123;int MF=0;while (Spfa(s,t,MC,MF));return MF;&#125;inline bool check(int D)&#123; E=0;memset(lnk,255,sizeof(lnk));memset(num,0,sizeof(num)); int ful=0;for (int i=1;i&lt;=m;i++) Add(x[i],y[i],0,1,1); for (int i=1;i&lt;=n;i++) if (d[i]&gt;=D) Add(i,T,d[i]-D,d[i]+D,0); else if (d[i]&lt;=-D) Add(S,i,-d[i]-D,-d[i]+D,0); else Add(S,i,0,D-d[i],0),Add(i,T,0,d[i]+D,0); for (int i=S;i&lt;=T;i++) if (num[i]&gt;0) Add(SS,i,0,num[i],0),ful+=num[i]; else if (num[i]&lt;0) Add(i,TT,0,-num[i],0); Add(T,S,0,INF,0);int ans=0,MAX=0;if (MCMF(SS,TT,ans)&lt;ful) return false; for (int j=lnk[SS];~j;j=nxt[j]) e[j].fr=e[j].sc,e[j^1].fr=e[j^1].sc; for (int j=lnk[TT];~j;j=nxt[j]) e[j].fr=e[j].sc,e[j^1].fr=e[j^1].sc; e[E-1].fr=e[E-1].sc;e[E-2].fr=e[E-2].sc;return MCMF(T,S,MAX),ans-MAX&lt;=K;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); for (int t=(scanf(\"%d\",&amp;te),1);t&lt;=te;t++)&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;K);K=m-K;memset(d,0,sizeof(d));ID.clear(); S=0;T=n+1;SS=T+1;TT=SS+1;int tot=0;char s[25];string now; for (int i=1;i&lt;=m;i++)&#123; scanf(\"%s\",s);d[x[i]=ID.count(now=string(s))?ID[now]:ID[now]=++tot]--; scanf(\"%s\",s);d[y[i]=ID.count(now=string(s))?ID[now]:ID[now]=++tot]++; &#125; int L=0,R=n,mid;while (L&lt;=R) check(mid=L+(R-L&gt;&gt;1))?R=mid-1:L=mid+1; printf(\"Case #%d:\\n%d\\n\",t,L); &#125; return 0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"HDU","slug":"Online-Judge/HDU","permalink":"https://zigzagk.github.io/categories/Online-Judge/HDU/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"},{"name":"二分","slug":"二分","permalink":"https://zigzagk.github.io/tags/二分/"}],"author":"ZigZagK"},{"title":"[树形DP+two-pointer]2016计蒜之道初赛第六场【微软的员工福利】题解","slug":"jisuanke11148","date":"2018-04-17T13:00:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/17/jisuanke11148/","link":"","permalink":"https://zigzagk.github.io/2018/04/17/jisuanke11148/","excerpt":"题目概述 有 \\(n\\) 个ZZK给JZ打工，他们的上下级关系是一棵树。现在JZ要给蒟蒻ZZK输送一定的神犇之力，每个ZZK可以得到 \\(r_i\\) 点神犇之力或者 \\(p_i\\) 点神犇之力。但是在ZZK得到神犇之力的同时会嫉妒直接下属ZZK得到的神犇之力，嫉妒会使得神犇之力削弱 \\(\\lceil{x\\over 1000}\\rceil\\times 666i\\) ，其中 \\(x\\) 是 \\(i\\) 直接下属的神犇之力（不考虑嫉妒）的极差，求 \\(n\\) 个ZZK获得神犇之力的和的最大值。","text":"题目概述 有 \\(n\\) 个ZZK给JZ打工，他们的上下级关系是一棵树。现在JZ要给蒟蒻ZZK输送一定的神犇之力，每个ZZK可以得到 \\(r_i\\) 点神犇之力或者 \\(p_i\\) 点神犇之力。但是在ZZK得到神犇之力的同时会嫉妒直接下属ZZK得到的神犇之力，嫉妒会使得神犇之力削弱 \\(\\lceil{x\\over 1000}\\rceil\\times 666i\\) ，其中 \\(x\\) 是 \\(i\\) 直接下属的神犇之力（不考虑嫉妒）的极差，求 \\(n\\) 个ZZK获得神犇之力的和的最大值。 解题报告 显然极差 \\(1000\\) 分一段，所以可以直接枚举极差，然后树形DP+two-pointer一下就行了。 颓太久了调代码能力下降，各种错误调了一个晚上。 示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long long LL;const int maxn=100000;int n,v[maxn+5][2];LL f[maxn+5][2];int E,lnk[maxn+5],nxt[(maxn&lt;&lt;1)+5],son[(maxn&lt;&lt;1)+5];int now,ha[maxn+5];pair&lt;int,int&gt; w[(maxn&lt;&lt;1)+5];#define Add(x,y) son[++E]=(y),nxt[E]=lnk[x],lnk[x]=Einline int ID(int L,int R,int x)&#123; bool A=L&lt;=v[x][0]&amp;&amp;v[x][0]&lt;=R,B=L&lt;=v[x][1]&amp;&amp;v[x][1]&lt;=R; if (A&amp;&amp;B) return 3;if (A) return 1;if (B) return 2;return 0;&#125;void DP(int x,int pre=0)&#123; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=pre) DP(son[j],x);now=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=pre) w[++now]=mp(v[son[j]][0],son[j]),w[++now]=mp(v[son[j]][1],son[j]); if (!now) &#123;f[x][0]=v[x][0];f[x][1]=v[x][1];return;&#125; w[++now]=mp(v[x][0],x);w[++now]=mp(v[x][1],x); sort(w+1,w+1+now);LL MAX[2];MAX[0]=MAX[1]=f[0][0]-1e18; for (int D=0;D&lt;=w[now].fr-w[1].fr+1000;D+=1000)&#123; int tot=0;LL sum=-(LL)D/1000*666*x; for (int i=1;i&lt;=now;i++) ha[w[i].sc]=0; for (int i=1,j=1,k,L,R;i&lt;=now;i=k)&#123; if (v[x][1]&lt;w[i].fr) break;L=w[i].fr;R=L+D; for (;j&lt;=now&amp;&amp;w[j].fr&lt;=R;ha[w[j++].sc]++) if (!ha[w[j].sc]) sum+=f[w[j].sc][ID(L,R,w[j].sc)==2],tot++; else sum+=max(f[w[j].sc][0],f[w[j].sc][1])-f[w[j].sc][0]; if (tot==(now&gt;&gt;1))&#123; int tp=ID(L,R,x); if (tp==1||tp==3) MAX[0]=max(MAX[0],sum+v[x][0]); if (tp==2||tp==3) MAX[1]=max(MAX[1],sum+v[x][1]); &#125; for (k=i;k&lt;=now&amp;&amp;w[i].fr==w[k].fr;ha[w[k++].sc]--) if (ha[w[k].sc]==1) sum-=f[w[k].sc][ID(L,R,w[k].sc)==2],tot--; else sum-=max(f[w[k].sc][0],f[w[k].sc][1])-f[w[k].sc][1]; &#125; &#125; f[x][0]=MAX[0];f[x][1]=MAX[1];&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); for (int i=(scanf(\"%d\",&amp;n),1);i&lt;=n;i++) &#123;scanf(\"%d%d\",&amp;v[i][0],&amp;v[i][1]);if (v[i][0]&gt;v[i][1]) swap(v[i][0],v[i][1]);&#125; for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),Add(x,y),Add(y,x); return DP(1),printf(\"%lld\\n\",max(f[1][0],f[1][1])),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"计蒜客","slug":"Online-Judge/计蒜客","permalink":"https://zigzagk.github.io/categories/Online-Judge/计蒜客/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"https://zigzagk.github.io/tags/树形DP/"},{"name":"two-pointer","slug":"two-pointer","permalink":"https://zigzagk.github.io/tags/two-pointer/"}],"author":"ZigZagK"},{"title":"[最小割]TopCoder【FoxAndCity】题解","slug":"TopCoderFoxAndCity","date":"2018-04-15T12:50:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/15/TopCoderFoxAndCity/","link":"","permalink":"https://zigzagk.github.io/2018/04/15/TopCoderFoxAndCity/","excerpt":"题目概述 有 \\(n\\) 个由双向边连通的城市，\\(1\\) 号城市里住着神犇JZ。\\(i\\) 号城市想要离JZ所在城市距离为 \\(want_i\\) ，如果实际的距离为 \\(real_i\\) ，那么就会有 \\((want_i-real_i)^2\\) 的不满意度。求任意加边后最小的不满意度。","text":"题目概述 有 \\(n\\) 个由双向边连通的城市，\\(1\\) 号城市里住着神犇JZ。\\(i\\) 号城市想要离JZ所在城市距离为 \\(want_i\\) ，如果实际的距离为 \\(real_i\\) ，那么就会有 \\((want_i-real_i)^2\\) 的不满意度。求任意加边后最小的不满意度。 解题报告 \\(n\\) 这么小……但显然不能DFS和状压DP，所以往网络流的方向想。 显然一个城市只能选择一个 \\(real\\) ，所以和切糕模型一样，把城市按照距离拆点后串起来，边的容量为不满意度。 限制是什么？因为可以任意加边，所以距离不可能比初始距离小，那么就需要把超过初始距离的边的容量改为 \\(INF\\) 。同时原先相邻的两个点距离之差不可能超过 \\(1\\) ，因此按照切糕模型的套路连边即可。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;const int maxn=40,maxt=maxn*maxn,maxm=(maxt+(maxt*maxn&lt;&lt;1))&lt;&lt;1,INF=2e9;class FoxAndCity&#123;#define ID(x,y) (((x)-1)*n+(y))#define sqr(x) ((x)*(x)) int n,E,lnk[maxt+5],son[maxm+5],nxt[maxm+5]; int que[maxt+5],dis[maxt+5],ti,vis[maxt+5],cur[maxt+5]; pair&lt;int,int&gt; e[maxm+5]; inline void Add(int x,int y,int z)&#123; son[E]=y;e[E]=mp(0,z);nxt[E]=lnk[x];lnk[x]=E++; son[E]=x;e[E]=mp(0,0);nxt[E]=lnk[y];lnk[y]=E++; &#125; inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;que[++Tail]=s;dis[s]=0;vis[s]=++ti; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;e[j].fr&lt;e[j].sc) que[++Tail]=u,dis[u]=dis[x]+1,vis[u]=ti; return vis[t]==ti; &#125; int Dfs(int x,int t,int MIN=INF)&#123; if (x==t||!MIN) return MIN;int now,f=0; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;(now=Dfs(son[j],t,min(MIN,e[j].sc-e[j].fr))))&#123; e[j].fr+=now;e[j^1].fr-=now;f+=now; if (!(MIN-=now)) break; &#125; return f; &#125;public: int minimalCost(vector &lt;string&gt; linked,vector &lt;int&gt; want)&#123; n=linked[0].size();int S=0,T=n*n+1;E=0;memset(lnk,255,sizeof(lnk)); int Head=0,Tail=0;que[++Tail]=1;dis[1]=0;vis[1]=++ti; while (Head!=Tail) for (int x=que[++Head],j=1;j&lt;=n;j++) if (vis[j]&lt;ti&amp;&amp;linked[x-1][j-1]=='Y') que[++Tail]=j,dis[j]=dis[x]+1,vis[j]=ti; for (int i=2;i&lt;=n;i++)&#123; Add(S,ID(i,1),sqr(want[i-1]-1)); for (int j=2;j&lt;=dis[i];j++) Add(ID(i,j-1),ID(i,j),sqr(want[i-1]-j)); for (int j=dis[i]+1;j&lt;n;j++) Add(ID(i,j-1),ID(i,j),INF); Add(ID(i,n-1),T,INF); &#125; for (int i=2;i&lt;=n;i++) for (int j=2;j&lt;=n;j++) if (linked[i-1][j-1]=='Y') for (int k=1;k&lt;=n;k++)&#123; if (k&gt;2) Add(ID(i,k-1),ID(j,k-2),INF); if (k&lt;n) Add(ID(j,k+1),ID(i,k),INF); &#125; int ans=0;while (Bfs(S,T)) memcpy(cur,lnk,sizeof(lnk)),ans+=Dfs(S,T); return ans; &#125;&#125;;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"TopCoder","slug":"Online-Judge/TopCoder","permalink":"https://zigzagk.github.io/categories/Online-Judge/TopCoder/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"}],"author":"ZigZagK"},{"title":"[TC交题指南]TopCoder【RangeEncoding】题解","slug":"TopCoderRangeEncoding","date":"2018-04-15T10:56:00.000Z","updated":"2019-07-25T07:13:41.070Z","comments":true,"path":"2018/04/15/TopCoderRangeEncoding/","link":"","permalink":"https://zigzagk.github.io/2018/04/15/TopCoderRangeEncoding/","excerpt":"题目概述 给出一个递增的数组，求 \\(a_i=a_{i-1}+1\\) 的段数。","text":"题目概述 给出一个递增的数组，求 \\(a_i=a_{i-1}+1\\) 的段数。 解题报告 TC交题方法比较鬼畜，不是读入输出，而是让你实现一个指定名称的class，里面写一个指定名称参数返回值的函数，然后按照题目的意思根据传入的参数返回答案。注意提交程序的时候不要带上调试用的int main。 等等，说好的题解呢？\\(ans=\\sum_{i=2}^{n}[a_{i-1}+1&lt;a_i]\\) ，完事。 示例程序 1234567891011#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;class RangeEncoding&#123;public: int minRanges(vector &lt;int&gt; a)&#123; int ans=1;for (int i=1;i&lt;a.size();i++) ans+=a[i-1]+1&lt;a[i]; return ans; &#125;&#125;;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"TopCoder","slug":"Online-Judge/TopCoder","permalink":"https://zigzagk.github.io/categories/Online-Judge/TopCoder/"}],"tags":[{"name":"划水","slug":"划水","permalink":"https://zigzagk.github.io/tags/划水/"}],"author":"ZigZagK"},{"title":"[最小割]BZOJ3144(Hnoi2013)【切糕】题解","slug":"BZOJ3144","date":"2018-04-11T15:22:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/11/BZOJ3144/","link":"","permalink":"https://zigzagk.github.io/2018/04/11/BZOJ3144/","excerpt":"题目概述 有一块 \\(X\\times Y\\times Z\\) 的切糕，每个点 \\((x,y,z)\\) 都有不和谐值 \\(v(x,y,z)\\) 。现在要切这块切糕，为每个直线 \\((x,y)\\) 选出一个点 \\(z\\) ，一种切法的不和谐值为选出点的不和谐值之和，为了平整还需要满足两条相邻的直线选出的点距离不超过 \\(D\\) 。求最小不和谐值。","text":"题目概述 有一块 \\(X\\times Y\\times Z\\) 的切糕，每个点 \\((x,y,z)\\) 都有不和谐值 \\(v(x,y,z)\\) 。现在要切这块切糕，为每个直线 \\((x,y)\\) 选出一个点 \\(z\\) ，一种切法的不和谐值为选出点的不和谐值之和，为了平整还需要满足两条相邻的直线选出的点距离不超过 \\(D\\) 。求最小不和谐值。 解题报告 声名远扬(?)的切糕模型，如果没有距离限制，我们可以把每个 \\((x,y)\\) 都从 \\(S\\) 到 \\(T\\) 串起来，像这样： 1S -&gt; 1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; T 将每条边的容量设置为不和谐值，然后求最小割就是最优解。 但是有限制，我们可以用容量为INF的边实现“屏蔽”效果，对于网络中的点 \\((x,y,z)\\) ，在 \\((x,y,z-1-D)\\to (x&#39;,y&#39;,z-1)\\) 和 \\((x&#39;,y&#39;,z+D)\\to (x,y,z)\\) 之间（ \\((x,y)\\) 与 \\((x&#39;,y&#39;)\\) 相邻）连容量为INF的边，这样就会形成一个 \\(S\\to (x,y,z-1)\\to (x&#39;,y&#39;,z-D)\\to (x&#39;,y&#39;,z+D)\\to (x,y,z)\\to T\\) 的“通路”，从而阻止其他边被选。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;const int maxn=40,maxt=maxn*maxn*maxn,maxe=(maxt+(maxt&lt;&lt;3))&lt;&lt;1;const int fl[4][2]=&#123;&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;1,0&#125;&#125;,INF=2e9;int X,Y,Z,D,n,ans;pair&lt;int,int&gt; e[maxe+5];int E,lnk[maxt+5],son[maxe+5],nxt[maxe+5];int que[maxt+5],dis[maxt+5],ti,vis[maxt+5],cur[maxt+5];inline int ID(int x,int y,int z) &#123;if (!z) return 0;return z&lt;Z?(x-1)*Y*Z+(y-1)*Z+z:n+1;&#125;inline void Add(int x,int y,int z)&#123; son[E]=y;e[E]=mp(0,z);nxt[E]=lnk[x];lnk[x]=E++; son[E]=x;e[E]=mp(0,0);nxt[E]=lnk[y];lnk[y]=E++;&#125;inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;que[++Tail]=s;vis[s]=++ti;dis[s]=0; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;e[j].fr&lt;e[j].sc) que[++Tail]=u,vis[u]=ti,dis[u]=dis[x]+1; return vis[t]==ti; &#125;int Dfs(int x,int t,int MIN=INF)&#123; if (x==t||!MIN) return MIN;int f=0,now; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;(now=Dfs(son[j],t,min(MIN,e[j].sc-e[j].fr))))&#123; e[j].fr+=now;e[j^1].fr-=now;f+=now; if (!(MIN-=now)) break; &#125; return f;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d%d%d\",&amp;X,&amp;Y,&amp;Z,&amp;D);n=X*Y*Z;E=0;memset(lnk,255,sizeof(lnk)); for (int z=1;z&lt;=Z;z++) for (int x=1;x&lt;=X;x++) for (int y=1,val;y&lt;=Y;y++) scanf(\"%d\",&amp;val),Add(ID(x,y,z-1),ID(x,y,z),val); for (int i=1;i&lt;=X;i++) for (int j=1;j&lt;=Y;j++) for (int f=0;f&lt;4;f++)&#123; int x=i+fl[f][0],y=j+fl[f][1]; if (x&lt;1||x&gt;X||y&lt;1||y&gt;Y) continue; for (int k=1;k&lt;=Z;k++)&#123; if (k&gt;D+1) Add(ID(i,j,k-1),ID(x,y,k-1-D),INF); if (k+D&lt;Z) Add(ID(i,j,k+D),ID(x,y,k),INF); &#125; &#125; while (Bfs(0,n+1)) memcpy(cur,lnk,sizeof(lnk)),ans+=Dfs(0,n+1); return printf(\"%d\\n\",ans),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"}],"author":"ZigZagK"},{"title":"[二分+后缀数组]BZOJ4310【跳蚤】题解","slug":"BZOJ4310","date":"2018-04-11T03:19:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/11/BZOJ4310/","link":"","permalink":"https://zigzagk.github.io/2018/04/11/BZOJ4310/","excerpt":"题目概述 有一个串 \\(S\\) ，现在要把 \\(S\\) 分成不超过 \\(K\\) 段，从每一个子串选出最大的子串，再从这些最大的子串中选出最大的串\"JZ串\"，求最小的\"JZ串\"（BZOJ题面有误，应该是最小的而不是最大的）。","text":"题目概述 有一个串 \\(S\\) ，现在要把 \\(S\\) 分成不超过 \\(K\\) 段，从每一个子串选出最大的子串，再从这些最大的子串中选出最大的串\"JZ串\"，求最小的\"JZ串\"（BZOJ题面有误，应该是最小的而不是最大的）。 解题报告 最大值最小想到二分，但是这怎么二分答案？直接二分串肯定是不行的，所以我们可以二分 \\(k\\) 表示第 \\(k\\) 大的串，至于怎么求第 \\(k\\) 大的串，后缀数组就可以解决。 然后我们考虑验证，在原串上跑，如果目前区间中有子串大于子串 \\(k\\)（用LCP判断即可），就说明需要换组。如果组的数量不超过 \\(K\\) 就验证成功。 如果正着来，每次添加了一个字符实际上添加了一堆子串，肯定会TLE。 所以我们反着来，会发现每次添加了一个字符产生的子串中只有最长的那个有用（显然），这样效率就正常了。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100000,Log=17;int K,n,l,r,SA[maxn+5],rk[maxn+5],t[(maxn&lt;&lt;1)+5],ha[maxn+5];int RMQ[maxn+5][Log+5],lg2[maxn+5];char s[maxn+5];inline void Sort(int n,int m)&#123; for (int i=0;i&lt;=m;i++) ha[i]=0;for (int i=1;i&lt;=n;i++) ha[rk[i]]++; for (int i=1;i&lt;=m;i++) ha[i]+=ha[i-1];for (int i=n;i;i--) SA[ha[rk[t[i]]]--]=t[i];&#125;inline void Make(int n)&#123; int m=256;for (int i=1;i&lt;=n;i++) rk[i]=s[i],t[i]=i;Sort(n,m); for (int k=1,p=0;p&lt;n;m=p,k&lt;&lt;1)&#123; p=0;for (int i=n-k+1;i&lt;=n;i++) t[++p]=i; for (int i=1;i&lt;=n;i++) if (SA[i]&gt;k) t[++p]=SA[i]-k; Sort(n,m);memcpy(t,rk,sizeof(rk));rk[SA[1]]=p=1; for (int i=2;i&lt;=n;rk[SA[i++]]=p) p+=t[SA[i-1]]!=t[SA[i]]||t[SA[i-1]+k]!=t[SA[i]+k]; &#125; for (int i=1,k=0;i&lt;=n;RMQ[rk[i++]][0]=k) &#123;if (k) k--;while (s[i+k]==s[SA[rk[i]-1]+k]) k++;&#125; for (int j=1;j&lt;=Log;j++) for (int i=2;i+(1&lt;&lt;j)-1&lt;=n;i++) RMQ[i][j]=min(RMQ[i][j-1],RMQ[i+(1&lt;&lt;j-1)][j-1]); for (int i=2;i&lt;=n;i++) lg2[i]=lg2[i&gt;&gt;1]+1;&#125;inline void getsub(LL mid)&#123; for (int i=1;i&lt;=n;i++)&#123; mid-=n-SA[i]+1-RMQ[i][0]; if (mid&lt;=0) &#123;l=SA[i];r=n+mid;return;&#125; &#125;&#125;inline int LCP(int x,int y)&#123; if (x==y) return n-x+1;x=rk[x];y=rk[y]; if (x&gt;y) swap(x,y);x++;int k=lg2[y-x+1]; return min(RMQ[x][k],RMQ[y-(1&lt;&lt;k)+1][k]);&#125;inline bool cmp(int L,int R,int l,int r)&#123; int lcp=LCP(L,l),A=R-L+1,B=r-l+1; if (lcp&gt;A) lcp=A;if (lcp&gt;B) lcp=B; if (lcp==A||lcp==B) return A&gt;B; return s[L+lcp]&gt;s[l+lcp];&#125;inline bool check(LL mid)&#123; getsub(mid);for (int i=1;i&lt;=n;i++) if (s[i]&gt;s[l]) return false; int k=1,lst=n;for (int i=n-1;i;i--) if (cmp(i,lst,l,r)) k++,lst=i; return k&lt;=K;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d\",&amp;K);scanf(\"%s\",s+1);Make(n=strlen(s+1));RMQ[1][0]=0; LL L=1,R=0;for (int i=1;i&lt;=n;i++) R+=n-SA[i]+1-RMQ[i][0]; for (LL mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) check(mid)?R=mid-1:L=mid+1; getsub(L);for (int i=l;i&lt;=r;i++) putchar(s[i]);return 0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://zigzagk.github.io/tags/二分/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://zigzagk.github.io/tags/后缀数组/"}],"author":"ZigZagK"},{"title":"[DP]UOJ300(CTSC2017)【吉夫特】题解","slug":"UOJ300","date":"2018-04-07T13:08:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/07/UOJ300/","link":"","permalink":"https://zigzagk.github.io/2018/04/07/UOJ300/","excerpt":"题目概述 求不上升OrzJZ子序列的个数，OrzJZ子序列需要满足 \\(\\prod_{i=2}^{k}{a_{i-1}\\choose a_i}\\ mod\\ 2=1\\) 。","text":"题目概述 求不上升OrzJZ子序列的个数，OrzJZ子序列需要满足 \\(\\prod_{i=2}^{k}{a_{i-1}\\choose a_i}\\ mod\\ 2=1\\) 。 解题报告 因为一个 \\(0\\) 都不能出现，根据Lucas定理，子序列必须前一项 \\(and\\) 后一项 \\(=\\) 后一项才能满足这个要求。那么我们就可以直接枚举子集来搞……题目里又有神助攻“没有相同的”，所以效率就是 \\(O(3^{log_2a_{max}})\\) 。 示例程序 1234567891011121314151617#include&lt;cstdio&gt;using namespace std;const int maxn=211985,maxa=262144,MOD=1e9+7;int n,pos[maxa],f[maxa],ans;inline void AMOD(int &amp;x,int tem) &#123;if ((x+=tem)&gt;=MOD) x-=MOD;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d\",&amp;n);for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),pos[x]=i,f[x]=1; for (int i=1;i&lt;maxa;i++) for (int j=pos[i]?i&amp;i-1:0;j;j=i&amp;j-1) if (pos[j]&gt;pos[i]) AMOD(f[i],f[j]); for (int i=1;i&lt;maxa;i++) if (pos[i]) AMOD(ans,f[i]-1); return printf(\"%d\\n\",ans),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"UOJ","slug":"Online-Judge/UOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/UOJ/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://zigzagk.github.io/tags/DP/"}],"author":"ZigZagK"},{"title":"[最大密度子图]2017计蒜之道初赛第三场【腾讯狼人杀】题解","slug":"jisuanke15549","date":"2018-04-07T07:59:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/07/jisuanke15549/","link":"","permalink":"https://zigzagk.github.io/2018/04/07/jisuanke15549/","excerpt":"题目概述 有 \\(n\\) 个神犇JZ，某两个JZ配合有神犇值，共有 \\(m\\) 组这样的JZ。现在要选出若干个JZ（假设选了 \\(k\\) 个），贡献为存在于这些JZ中的所有配合的神犇值之和除以 \\(k(2n-k)\\) ，求最大贡献。","text":"题目概述 有 \\(n\\) 个神犇JZ，某两个JZ配合有神犇值，共有 \\(m\\) 组这样的JZ。现在要选出若干个JZ（假设选了 \\(k\\) 个），贡献为存在于这些JZ中的所有配合的神犇值之和除以 \\(k(2n-k)\\) ，求最大贡献。 解题报告 显然是最大密度子图啊？但是我太naive了，一直在想怎么把 \\(k(2n-k)\\) 放进点权里，实际上应该放到边权里……先二分，然后推一推： \\[ {\\sum w_{i,j}\\over k(2n-k)}\\ge mid\\\\ \\sum w_{i,j}-k(2n-k)mid\\ge 0\\\\ \\sum w_{i,j}-2nkmid+k^2mid\\ge 0\\\\ \\sum w_{i,j}-2nkmid+kmid+{k(k-1)\\over 2}2mid\\ge 0\\\\ \\sum(w_{i,j}+mid)-(2n-1)kmid\\ge 0 \\] 再就很明显了……新边权为 \\(w_{i,j}+mid\\) ，新点权为 \\((2n-1)mid\\) ，刷最大密度子图就行了。 示例程序 精度坑死人！！！我恨分数规划！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long double DB;const int maxn=400,maxm=maxn*maxn,maxe=maxm+maxn&lt;&lt;2;int n,m,w[maxn+5][maxn+5];bool chs[maxn+5];int E,lnk[maxn+5],cur[maxn+5],son[maxe+5],nxt[maxe+5];DB D[maxn+5];pair&lt;DB,DB&gt; e[maxe+5];int que[maxn+5],dis[maxn+5],ti,vis[maxn+5];inline int fcmp(DB a,DB b) &#123;if (fabs(a-b)&lt;1e-10) return 0;if (a&lt;b) return -1;return 1;&#125;inline void Add(int x,int y,DB z)&#123; son[E]=y;e[E]=mp(0,z);nxt[E]=lnk[x];lnk[x]=E++; son[E]=x;e[E]=mp(0,0);nxt[E]=lnk[y];lnk[y]=E++;&#125;inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;que[++Tail]=s;vis[s]=++ti;dis[s]=0; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;fcmp(e[j].fr,e[j].sc)&lt;0) que[++Tail]=u,vis[u]=ti,dis[u]=dis[x]+1; return vis[t]==ti;&#125;DB Dfs(int x,int t,DB MIN=1e18)&#123; if (x==t||!fcmp(MIN,0)) return MIN;DB now,f=0; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;fcmp(now=Dfs(son[j],t,min(MIN,e[j].sc-e[j].fr)),0))&#123; e[j].fr+=now;e[j^1].fr-=now;f+=now; if (!fcmp(MIN-=now,0)) break; &#125; return f;&#125;inline bool check(DB mid)&#123; DB U=n*(2*mid+100);E=0;memset(lnk,255,sizeof(lnk));memset(D,0,sizeof(D)); for (int i=1;i&lt;n;i++) for (int j=i+1;j&lt;=n;j++)&#123; Add(i,j,w[i][j]+2*mid);Add(j,i,w[i][j]+2*mid); D[i]+=w[i][j]+2*mid;D[j]+=w[i][j]+2*mid; &#125; for (int i=1;i&lt;=n;i++) Add(0,i,chs[i]?1e18:U),Add(i,n+1,U+2*mid*(2*n-1)-D[i]); DB MAX=0;while (Bfs(0,n+1)) memcpy(cur,lnk,sizeof(lnk)),MAX+=Dfs(0,n+1); return fcmp(U*n,MAX)&gt;0;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1,x,y,z;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),w[x][y]=w[y][x]=z; for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),chs[i]=x; DB L=0,R=m*100,mid;while (fcmp(R-L,1e-8)&gt;0) check(mid=(L+R)/2)?L=mid:R=mid; return printf(\"%.6f\\n\",(double)L),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"计蒜客","slug":"Online-Judge/计蒜客","permalink":"https://zigzagk.github.io/categories/Online-Judge/计蒜客/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"},{"name":"分数规划","slug":"分数规划","permalink":"https://zigzagk.github.io/tags/分数规划/"}],"author":"ZigZagK"},{"title":"[决策单调性]BZOJ2369【区间】题解","slug":"BZOJ2369","date":"2018-04-02T03:47:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/04/02/BZOJ2369/","link":"","permalink":"https://zigzagk.github.io/2018/04/02/BZOJ2369/","excerpt":"题目概述 有 \\(n\\) 个区间 \\(A_i=[L_i,R_i]\\) ，现在选 \\(m\\) 个 \\((m&gt;1)\\) 区间，贡献为 \\(|A_{k_1}\\cap A_{k_2}\\cap A_{k_3}\\cdots A_{k_m}|\\times|A_{k_1}\\cup A_{k_2}\\cup A_{k_3}\\cdots A_{k_m}|\\) ，求最大贡献。","text":"题目概述 有 \\(n\\) 个区间 \\(A_i=[L_i,R_i]\\) ，现在选 \\(m\\) 个 \\((m&gt;1)\\) 区间，贡献为 \\(|A_{k_1}\\cap A_{k_2}\\cap A_{k_3}\\cdots A_{k_m}|\\times|A_{k_1}\\cup A_{k_2}\\cup A_{k_3}\\cdots A_{k_m}|\\) ，求最大贡献。 解题报告 显然最大贡献是只选两个区间，所以我们先把区间排序，去掉被包含的区间（注意去重时也需要计算贡献），然后就可以定义 \\(f_i=max\\{(R_j-L_i)(R_i-L_j)|j&lt;i\\}\\) 表示 \\(i\\) 的最大贡献。 决策单调性是什么呢？和斜率优化类似，如果 \\(j\\) 对于 \\(k\\) 比 \\(i\\) 好能够推出对于 \\(t(t&gt;k)\\) \\(j\\) 也比 \\(i\\) 好，就说明决策点是单调的，这样就可以减少很多没有必要的枚举。 对于这题，令 \\(i&lt;j&lt;k&lt;t\\) ，假设 \\(j\\) 比 \\(i\\) 好，那么： \\[ (R_k-L_j)(R_j-L_k)&gt;(R_k-L_i)(R_i-L_k)\\\\ R_jR_k-R_kL_k-R_jL_j+L_jL_k&gt;R_iR_k-R_kL_k-R_iL_i+L_iL_k\\\\ R_k(R_j-R_i)+L_k(L_j-L_i)&gt;R_jL_j-R_iL_i\\\\ \\because L_t&gt;L_k,R_t&gt;R_k\\\\ R_t(R_j-R_i)+L_t(L_j-L_i)&gt;R_jL_j-R_iL_i\\\\ (R_t-L_j)(R_j-L_t)&gt;(R_t-L_i)(R_i-L_t)\\\\ \\] 所以满足决策单调性，我们就可以分治了！\\(Solve(L,R,l,r)\\) 表示求出 \\(f_{[L,R]}\\) ，决策点范围在 \\([l,r]\\) 。那么我们可以先求出 \\(f_{mid}\\) 的决策点 \\(pos\\) ，然后 \\(Solve(L,mid,l,pos),Solve(mid+1,R,pos,r)\\) 就行了。 注意决策单调性并不一定都能够用分治，因为很明显 \\(f\\) 在 \\(Solve\\) 之前是未知的，所以如果 \\(f\\) 的转移方程中包含 \\(f\\) 就不能够用分治了。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define fr first#define sc secondusing namespace std;typedef long long LL;const int maxn=1000000;int n;LL ans;pair&lt;int,int&gt; s[maxn+5];bool vis[maxn+5];#define Eoln(x) ((x)==10||(x)==13||(x)==EOF)inline char readc()&#123; static char buf[100000],*l=buf,*r=buf; if (l==r) r=(l=buf)+fread(buf,1,100000,stdin); if (l==r) return EOF;return *l++;&#125;inline int readi(int &amp;x)&#123; int tot=0;char ch=readc(),lst='+'; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+ch-48,ch=readc(); return lst=='-'?x=-tot:x=tot,Eoln(ch);&#125;inline bool cmp(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b) &#123;return a.fr&lt;b.fr||a.fr==b.fr&amp;&amp;a.sc&gt;b.sc;&#125;#define val(i,j) ((LL)(s[j].sc-s[i].fr)*(s[i].sc-s[j].fr))LL Solve(int L,int R,int l,int r)&#123; if (L==R) &#123;LL MAX=0;for (int i=l;i&lt;=r&amp;&amp;i&lt;L;i++) MAX=max(MAX,val(i,L));return MAX;&#125; int mid=L+(R-L&gt;&gt;1);LL MAX=0;int pos=mid; for (int i=l;i&lt;=r&amp;&amp;i&lt;mid;i++) if (val(i,mid)&gt;MAX) MAX=val(i,mid),pos=i; return max(MAX,max(Solve(L,mid,l,pos),Solve(mid+1,R,pos,r)));&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); readi(n);for (int i=1;i&lt;=n;i++) readi(s[i].fr),readi(s[i].sc);sort(s+1,s+1+n); for (int i=1,j;i&lt;=n;i=j) for (j=i+1;j&lt;=n;vis[j++]=true)&#123; if (s[j].sc&gt;s[i].sc) break; ans=max(ans,(LL)(s[i].sc-s[i].fr)*(s[j].sc-s[j].fr)); &#125; for (int tot=n,i=(n=0,1);i&lt;=tot;i++) if (!vis[i]) s[++n]=s[i]; if (n==1) return printf(\"%lld\\n\",ans),0; return printf(\"%lld\\n\",max(ans,Solve(2,n,1,n-1))),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"决策单调性","slug":"决策单调性","permalink":"https://zigzagk.github.io/tags/决策单调性/"}],"author":"ZigZagK"},{"title":"[DP]BZOJ1566(NOI2009)【管道取珠】题解","slug":"BZOJ1566","date":"2018-03-29T13:04:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/29/BZOJ1566/","link":"","permalink":"https://zigzagk.github.io/2018/03/29/BZOJ1566/","excerpt":"题目概述 有两个管道，第一个有 \\(n\\) 个黑白珠子，第二个有 \\(m\\) 个黑白珠子，每次可以从一个管道取出最靠管道口的珠子。假设有 \\(k\\) 中取珠子的方法，第 \\(i\\) 种方案的方案数为 \\(a_i\\) 那么贡献为 \\(\\sum_{i=1}^{k}a_i^2\\) 。求贡献。","text":"题目概述 有两个管道，第一个有 \\(n\\) 个黑白珠子，第二个有 \\(m\\) 个黑白珠子，每次可以从一个管道取出最靠管道口的珠子。假设有 \\(k\\) 中取珠子的方法，第 \\(i\\) 种方案的方案数为 \\(a_i\\) 那么贡献为 \\(\\sum_{i=1}^{k}a_i^2\\) 。求贡献。 解题报告 开平方可以理解为每种方案都和相同的方案有贡献，所以我们可以认为有两个取珠游戏同时进行，且只有两个游戏取出来的方案一样时才有贡献，也就是说： 定义 \\(f[i][j][k][t]\\) 表示第一个游戏的第一个管道取了 \\(i\\) 个，第二个管道取了 \\(j\\) 个；第二个游戏的第一个管道取了 \\(k\\) 个，第二个管道取了 \\(t\\) 个的贡献，那么就只有当每次取出来的珠子颜色相同才能转移，就变成了很简单的DP。 实际上因为 \\(i+j=k+t\\) ，所以只需要 \\(f[i][j][k]\\) 就行了。 示例程序 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cctype&gt;using namespace std;const int maxn=500,MOD=1024523;int n,m,a[maxn+5],b[maxn+5];int f[maxn+5][maxn+5][maxn+5];inline char getupr() &#123;char ch=getchar();while (!isupper(ch)) ch=getchar();return ch;&#125;inline void AMOD(int &amp;x,int tem) &#123;if ((x+=tem)&gt;=MOD) x-=MOD;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for (int i=n;i;i--) a[i]=getupr()-'A'; for (int i=m;i;i--) b[i]=getupr()-'A'; f[0][0][0]=1; for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;=m;j++) for (int k=0,t=i+j;k&lt;=i+j&amp;&amp;k&lt;=n;k++,t--)&#123; int &amp;F=f[i][j][k]; if (i&amp;&amp;t&amp;&amp;a[i]==b[t]) AMOD(F,f[i-1][j][k]); if (i&amp;&amp;k&amp;&amp;a[i]==a[k]) AMOD(F,f[i-1][j][k-1]); if (j&amp;&amp;t&amp;&amp;b[j]==b[t]) AMOD(F,f[i][j-1][k]); if (j&amp;&amp;k&amp;&amp;b[j]==a[k]) AMOD(F,f[i][j-1][k-1]); &#125; return printf(\"%d\\n\",f[n][m][n]),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://zigzagk.github.io/tags/DP/"}],"author":"ZigZagK"},{"title":"简单解决hexo-theme-yilia Markdown列表显示错误的问题","slug":"YiliaMarkdownList","date":"2018-03-20T09:50:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/20/YiliaMarkdownList/","link":"","permalink":"https://zigzagk.github.io/2018/03/20/YiliaMarkdownList/","excerpt":"建立Hexo静态博客之后，我一眼相中了Litten大大的yilia主题。我对这款主题基本上满意，一些不满意的地方即使困扰已久折腾之后也魔改掉了（比如代码片什么的QAQ）。 不过有一次忽然发现yilia主题Markdown列表嵌套（好像夹杂代码片也会）会显示出错……作为一个强迫症重度患者，这就很不能忍……","text":"建立Hexo静态博客之后，我一眼相中了Litten大大的yilia主题。我对这款主题基本上满意，一些不满意的地方即使困扰已久折腾之后也魔改掉了（比如代码片什么的QAQ）。 不过有一次忽然发现yilia主题Markdown列表嵌套（好像夹杂代码片也会）会显示出错……作为一个强迫症重度患者，这就很不能忍…… 比之前折腾了更久之后……今天了发现问题所在：（因为我并不是很懂webpack什么的……所以就直接改在main.*.css上了XD） 123ol,ul &#123; list-style:none outside none&#125; 啥玩意啊这是……度娘之后发现这货取消了主题中所有列表的开头符（包括有序列表的前置数字），然后再看文章配置中： 1234567.article-entry ul li:before &#123; ......&#125;.......article-entry li ol li:before,.article-entry li ul li:before&#123; ......&#125; 这两个应该是Litten大大自己配置的列表开头符。 去Lynstery和linkfqy的主题配置里看了看，发现基本没有配置过列表？事实上，浏览器会自带列表样式（就是开发者模式里显示的user agent stylesheet），所以我们可以去掉Litten大大配置的列表开头符，然后干掉前面说的那个取消开头符的语句，会发现列表正常了!（ps：稍微正常点的浏览器都自带列表样式，所以不需要特别担心兼容性。再ps：去掉代码之后列表位置会有些奇怪，稍微修改样式即可。） 但是……侧边栏菜单都多出了列表开头符……我们可以在侧边栏菜单的样式中添加list-style-type: none;，就可以和以前一样了。同理标签等列表前面也会多出开头符，手动添加代码即可。 因为水平有限，不能做到保留Litten大大的样式，这种更难的活就交给熟练掌握css的大佬吧QwQ。列表实例： 我是一级列表 我是文字 我是二级列表 123#include&lt;cstdio&gt;using namespace std;int main() &#123;return 0;&#125; 我是三级列表 我是有序列表1 Orz%%%Lynstery 我是有序列表2 我还是一级列表 是不是很棒棒啊！","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"},{"name":"Hexo","slug":"杂/Hexo","permalink":"https://zigzagk.github.io/categories/杂/Hexo/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}],"author":"ZigZagK"},{"title":"[wqs二分+DP]POJ1160【Post Office】题解","slug":"POJ1160","date":"2018-03-15T07:54:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/15/POJ1160/","link":"","permalink":"https://zigzagk.github.io/2018/03/15/POJ1160/","excerpt":"题目概述 有 \\(n\\) 个村庄，现在要建 \\(m\\) 个邮局，一种方案的代价是每个村庄到最近的邮局的距离之和。","text":"题目概述 有 \\(n\\) 个村庄，现在要建 \\(m\\) 个邮局，一种方案的代价是每个村庄到最近的邮局的距离之和。 解题报告 显然是 \\(O(n^2m)\\) DP吧？数据小的可怜，这样就可以过了…… 不过有一种更好的方法，可以把 \\(m\\) 优化到 \\(log_2m\\) ，这就是wqs(%%%Orz)二分了。 想法是这样的：去掉 \\(f[i][j]\\) (前 \\(i\\) 个村庄中建了 \\(j\\) 个邮局)中的 \\(j\\) ，枚举一个 \\(cost\\) 表示建邮局需要额外的 \\(cost\\) 花费，再记录一个 \\(g[i]\\) 表示前 \\(i\\) 个村庄在最优解的情况下最少建多少邮局。接下来刷DP，如果 \\(g[n]\\le m\\) 就说明可行。由此可见 \\(cost\\) 是可以二分枚举的，所以我们就可以愉快的把 \\(O(n^2m)\\) 优化成 \\(O(n^2log_2m)\\) 。 严格的来说，只有当原函数 \\(g(x)\\) 的斜率单调，才可以这么处理。因为枚举 \\(cost\\) 实际上是一个逼近 \\(g(x)\\) 斜率的过程 \\([g(x)-x\\cdot cost]&#39;=g&#39;(x)-cost\\) ，如果 \\(g&#39;(x)\\) 不是单调的，就没办法二分枚举 \\(cost\\) 了。 还有要注意的是，最后并不一定刚好停在 \\(m\\) 个的位置，不过这并没有什么关系（反正答案是一样的），只不过算答案的时候不能用 \\(f[n]-g[n]\\cdot cost\\) ，一定要用 \\(f[n]-m\\cdot cost\\) ，因为题目要求的是 \\(m\\) 个。 另一道经典的wqs二分是BZOJ2654，那时候说这二分怎么这么神奇，原来是wqs二分QAQ。 示例程序 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=300;int n,m,dis[maxn+5],pre[maxn+5][maxn+5],suf[maxn+5][maxn+5],w[maxn+5][maxn+5];int f[maxn+5],g[maxn+5];inline void Fix(int fj,int gj,int &amp;fi,int &amp;gi) &#123;if (fj&lt;fi||fj==fi&amp;&amp;gj&lt;gi) fi=fj,gi=gj;&#125;inline bool check(int cst)&#123; memset(f,63,sizeof(f));f[0]=0;g[0]=0; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;i;j++) Fix(f[j]+w[j+1][i]+cst,g[j]+1,f[i],g[i]); return g[n]&lt;=m;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m);for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;dis[i]); for (int i=1;i&lt;=n;i++) for (int j=i;j;j--) pre[j][i]=pre[j+1][i]+dis[i]-dis[j]; for (int i=1;i&lt;=n;i++) for (int j=i;j&lt;=n;j++) suf[i][j]=suf[i][j-1]+dis[j]-dis[i]; for (int i=1,k;i&lt;=n;i++) for (int j=(k=i);j&lt;=n;j++) w[i][j]=pre[i][i+j&gt;&gt;1]+suf[i+j&gt;&gt;1][j]; int L=0,R=dis[n]*n; for (int mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) check(mid)?R=mid-1:L=mid+1; return check(L),printf(\"%d\\n\",f[n]-m*L),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"POJ","slug":"Online-Judge/POJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/POJ/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://zigzagk.github.io/tags/DP/"},{"name":"二分","slug":"二分","permalink":"https://zigzagk.github.io/tags/二分/"}],"author":"ZigZagK"},{"title":"[最大密度子图]POJ3155【Hard Life】题解","slug":"POJ3155","date":"2018-03-14T06:28:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/14/POJ3155/","link":"","permalink":"https://zigzagk.github.io/2018/03/14/POJ3155/","excerpt":"题目概述 有 \\(n\\) 个员工 \\(m\\) 条矛盾，现在要炒若干个员工的鱿鱼，一组方案的权值是矛盾数与员工数的比值。求最大比值的方案。","text":"题目概述 有 \\(n\\) 个员工 \\(m\\) 条矛盾，现在要炒若干个员工的鱿鱼，一组方案的权值是矛盾数与员工数的比值。求最大比值的方案。 解题报告 最大密度子图模板题。双倍经验BZOJ1312，没权限号就在POJ做了。 精度略有毒，我之前的二分写法一直卡不过去，看来以后还是换成这次这种二分写法吧QAQ。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long double DB;const int maxn=100,maxm=1000,maxe=maxn+maxm&lt;&lt;2;int n,m,x[maxm+5],y[maxm+5],D[maxn+5],ans;int E,lnk[maxn+5],nxt[maxe+5],son[maxe+5];int cur[maxn+5],que[maxn+5],ti,vis[maxn+5],dis[maxn+5];pair&lt;DB,DB&gt; e[maxe+5];inline int fcmp(DB a,DB b) &#123;if (fabs(a-b)&lt;1e-8) return 0;if (a&lt;b) return -1;return 1;&#125;inline void Add(int x,int y,DB z)&#123; son[E]=y;e[E]=mp(0,z);nxt[E]=lnk[x];lnk[x]=E++; son[E]=x;e[E]=mp(0,0);nxt[E]=lnk[y];lnk[y]=E++;&#125;inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;que[++Tail]=s;vis[s]=++ti;dis[s]=0; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;fcmp(e[j].fr,e[j].sc)&lt;0) que[++Tail]=u,vis[u]=ti,dis[u]=dis[x]+1; return vis[t]==ti;&#125;DB Dfs(int x,int gl,DB MIN=1e100)&#123; if (x==gl||!fcmp(MIN,0)) return MIN;DB f=0,now; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;fcmp(now=Dfs(son[j],gl,min(MIN,e[j].sc-e[j].fr)),0))&#123; f+=now;e[j].fr+=now;e[j^1].fr-=now; if (!fcmp(MIN-=now,0)) break; &#125; return f;&#125;inline bool check(DB mid)&#123; E=0;memset(lnk,255,sizeof(lnk));DB ans=0; for (int i=1;i&lt;=n;i++) Add(0,i,m),Add(i,n+1,m+2*mid-D[i]); for (int i=1;i&lt;=m;i++) Add(x[i],y[i],1),Add(y[i],x[i],1); while (Bfs(0,n+1)) memcpy(cur,lnk,sizeof(lnk)),ans+=Dfs(0,n+1); return fcmp((DB)m*n,ans)&gt;0;&#125;void Dfs(int x)&#123; for (int j=(vis[x]=ti,lnk[x]);~j;j=nxt[j]) if (fcmp(e[j].fr,e[j].sc)&lt;0) if (vis[son[j]]&lt;ti) ans++,Dfs(son[j]);&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m);for (int i=1;i&lt;=m;i++) scanf(\"%d%d\",&amp;x[i],&amp;y[i]),D[x[i]]++,D[y[i]]++; if (!m) return puts(\"1\"),puts(\"1\"),0;DB L=(DB)1/n,R=m; for (DB mid=(L+R)/2;fcmp(1e-5,R-L)&lt;0;mid=(L+R)/2) check(mid)?L=mid:R=mid; E=0;memset(lnk,255,sizeof(lnk)); for (int i=1;i&lt;=n;i++) Add(0,i,m),Add(i,n+1,m+2*L-D[i]); for (int i=1;i&lt;=m;i++) Add(x[i],y[i],1),Add(y[i],x[i],1); while (Bfs(0,n+1)) memcpy(cur,lnk,sizeof(lnk)),Dfs(0,n+1); ti++;Dfs(0);printf(\"%d\\n\",ans);for (int i=1;i&lt;=n;i++) if (vis[i]==ti) printf(\"%d\\n\",i); return 0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"},{"name":"分数规划","slug":"分数规划","permalink":"https://zigzagk.github.io/tags/分数规划/"}],"author":"ZigZagK"},{"title":"[最小割+Tarjan]BZOJ1797(Ahoi2009)【Mincut 最小割】题解","slug":"BZOJ1797","date":"2018-03-12T07:45:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/12/BZOJ1797/","link":"","permalink":"https://zigzagk.github.io/2018/03/12/BZOJ1797/","excerpt":"题目概述 给出一张 \\(n\\) 个点 \\(m\\) 条有向边的图，现在要求 \\(S,T\\) 的最小割，问每一条边： 有没有可能出现在最小割中。 是否一定出现在最小割中。","text":"题目概述 给出一张 \\(n\\) 个点 \\(m\\) 条有向边的图，现在要求 \\(S,T\\) 的最小割，问每一条边： 有没有可能出现在最小割中。 是否一定出现在最小割中。 解题报告 先跑出随意一种最小割（最大流），然后在残量网络里缩点，接下来好像有结论？ \\((x,y)\\) 可能出现：\\(SCC_x\\not=SCC_y\\) 。 \\((x,y)\\) 一定出现：\\(SCC_S=SCC_x,SCC_y=SCC_T\\) 。 yy一下还是挺显然的。因为缩点之后只剩下满流边，所以新图中每一种割都恰好对应原来的一种最小割，只要 \\(x,y\\) 不在同一个强连通分量中，就可以被切断（从而形成某种最小割）；如果 \\(S\\) 和 \\(x\\) 在一起而 \\(y\\) 和 \\(T\\) 在一起，就说明 \\((x,y)\\) 必须切断才可能切断 \\(S\\) 到 \\(T\\) 。最后再注意一下流量为 \\(0\\) 的边就行了。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;const int maxn=4000,maxm=60000;int n,m,S,T,x[maxm+5],y[maxm+5],z[maxm+5];int dfn[maxn+5],low[maxn+5],top,stk[maxn+5],SCC[maxn+5];int E,lnk[maxn+5],son[(maxm&lt;&lt;1)+5],nxt[(maxm&lt;&lt;1)+5];int cur[maxn+5],que[maxn+5],ti,vis[maxn+5],dis[maxn+5];bool instk[maxn+5];pair&lt;int,int&gt; e[(maxm&lt;&lt;1)+5];inline void Add(int x,int y,int z)&#123; son[E]=y;e[E]=mp(0,z);nxt[E]=lnk[x];lnk[x]=E++; son[E]=x;e[E]=mp(0,0);nxt[E]=lnk[y];lnk[y]=E++;&#125;inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;que[++Tail]=s;vis[s]=++ti;dis[s]=0; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;e[j].fr&lt;e[j].sc) que[++Tail]=u,vis[u]=ti,dis[u]=dis[x]+1; return vis[t]==ti;&#125;int Dfs(int x,int gl,int MIN=2e9)&#123; if (x==gl||!MIN) return MIN;int f=0,now; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;(now=Dfs(son[j],gl,min(MIN,e[j].sc-e[j].fr))))&#123; f+=now;e[j].fr+=now;e[j^1].fr-=now; if (!(MIN-=now)) break; &#125; return f;&#125;void Tarjan(int x)&#123; dfn[x]=low[x]=++ti;stk[++top]=x;instk[x]=true; for (int j=lnk[x];~j;j=nxt[j]) if (e[j].fr&lt;e[j].sc) if (!dfn[son[j]]) Tarjan(son[j]),low[x]=min(low[x],low[son[j]]); else if (instk[son[j]]) low[x]=min(low[x],dfn[son[j]]); if (dfn[x]==low[x]) for (int y=(SCC[0]++,stk[top--]);;y=stk[top--]) &#123;SCC[y]=SCC[0];instk[y]=false;if (x==y) break;&#125;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;S,&amp;T);E=0;memset(lnk,255,sizeof(lnk)); for (int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;x[i],&amp;y[i],&amp;z[i]),Add(x[i],y[i],z[i]); while (Bfs(S,T)) memcpy(cur,lnk,sizeof(lnk)),Dfs(S,T); for (int i=1;i&lt;=n;i++) if (!dfn[i]) Tarjan(i); for (int i=1;i&lt;=m;i++)&#123; if (e[i-1&lt;&lt;1].fr&lt;e[i-1&lt;&lt;1].sc) &#123;puts(\"0 0\");continue;&#125; putchar((SCC[x[i]]!=SCC[y[i]])+48);putchar(' '); putchar((SCC[S]==SCC[x[i]]&amp;&amp;SCC[y[i]]==SCC[T])+48);puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://zigzagk.github.io/tags/强连通分量/"}],"author":"ZigZagK"},{"title":"[最大权闭合图]BZOJ4873(Shoi2017)【寿司餐厅】题解","slug":"BZOJ4873","date":"2018-03-10T07:41:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/10/BZOJ4873/","link":"","permalink":"https://zigzagk.github.io/2018/03/10/BZOJ4873/","excerpt":"题目概述 题目太复杂了QAQ，自己去看吧……吃我传送门。","text":"题目概述 题目太复杂了QAQ，自己去看吧……吃我传送门。 解题报告 很显然最优解一定是选若干个不相交的区间。我们观察题目里的条件，发现带有很多“强制”操作，比如吃了 \\([L,R]\\) ，里面的所有子区间贡献都会被算上，且 \\([L,R]\\) 中所有寿司种类都要付钱…… 由此我们想到这是最大权闭合图，分一下类，有“代号”，“寿司”，“区间”这三种点，然后开始建图： 寿司 \\(i\\) (区间 \\([i,i]\\) ) \\(\\to\\) 代号 \\(a_i\\) ：容量 \\(+\\infty\\) 。 区间 \\([L,R]\\to [L+1,R],[L,R-1]\\) ：容量 \\(+\\infty\\) 。 代号 \\(i\\to T\\) ：容量 \\(mi^2\\) 。 寿司 \\(i\\) 点权 \\(d[i][i]-a[i]\\) ：根据点权正负建边。 区间 \\([L,R]\\) 点权 \\(d[L][R]\\) ：根据点权正负建边。 示例程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;const int maxn=100,maxt=6050,maxm=maxt*3,MAXINT=((1&lt;&lt;30)-1)*2+1;int n,m,a[maxn+5],d[maxn+5][maxn+5],ID[maxn+5][maxn+5],S=0,T=maxt+1;int E,lnk[maxt+5],son[(maxm&lt;&lt;1)+5],nxt[(maxm&lt;&lt;1)+5];int cur[maxt+5],que[maxt+5],ti,vis[maxt+5],dis[maxt+5],ans;pair&lt;int,int&gt; e[(maxm&lt;&lt;1)+5];inline void Add(int x,int y,int z)&#123; son[E]=y;nxt[E]=lnk[x];e[E]=mp(0,z);lnk[x]=E++; son[E]=x;nxt[E]=lnk[y];e[E]=mp(0,0);lnk[y]=E++;&#125;inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;que[++Tail]=s;vis[s]=++ti;dis[s]=0; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;e[j].fr&lt;e[j].sc) que[++Tail]=u,vis[u]=ti,dis[u]=dis[x]+1; return vis[t]==ti;&#125;int Dfs(int x,int gl,int MIN=MAXINT)&#123; if (x==gl||!MIN) return MIN;int f=0,now; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;(now=Dfs(son[j],gl,min(MIN,e[j].sc-e[j].fr))))&#123; f+=now;e[j].fr+=now;e[j^1].fr-=now; if (!(MIN-=now)) break; &#125; return f;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m);E=0;memset(lnk,255,sizeof(lnk)); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for (int i=1;i&lt;=n;i++) for (int j=i;j&lt;=n;j++) scanf(\"%d\",&amp;d[i][j]),ID[i][j]=++ID[0][0]; for (int i=1;i&lt;=n;i++) Add(ID[i][i],T-a[i],MAXINT); for (int i=1;i&lt;n;i++) for (int j=i+1;j&lt;=n;j++) Add(ID[i][j],ID[i+1][j],MAXINT),Add(ID[i][j],ID[i][j-1],MAXINT); for (int i=1;i&lt;=1000;i++) Add(T-i,T,m*i*i); for (int i=1;i&lt;=n;i++) d[i][i]-a[i]&lt;0?Add(ID[i][i],T,a[i]-d[i][i]):(ans+=d[i][i]-a[i],Add(S,ID[i][i],d[i][i]-a[i])); for (int i=1;i&lt;n;i++) for (int j=i+1;j&lt;=n;j++) d[i][j]&lt;0?Add(ID[i][j],T,-d[i][j]):(ans+=d[i][j],Add(S,ID[i][j],d[i][j])); while (Bfs(S,T)) memcpy(cur,lnk,sizeof(lnk)),ans-=Dfs(S,T); return printf(\"%d\\n\",ans),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"}],"author":"ZigZagK"},{"title":"[最大权闭合图]BZOJ1497(NOI2006)【最大获利】题解","slug":"BZOJ1497","date":"2018-03-08T13:14:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/08/BZOJ1497/","link":"","permalink":"https://zigzagk.github.io/2018/03/08/BZOJ1497/","excerpt":"题目概述 有 \\(n\\) 个点 \\(m\\) 条边，每个点需要花费 \\(p_i\\) 购买，每条边可以得到 \\(c_i\\) 的价值。现在要购买一些点，如果一条边两端的点都被购买了，就可以得到这条边的价值。求最大价值。","text":"题目概述 有 \\(n\\) 个点 \\(m\\) 条边，每个点需要花费 \\(p_i\\) 购买，每条边可以得到 \\(c_i\\) 的价值。现在要购买一些点，如果一条边两端的点都被购买了，就可以得到这条边的价值。求最大价值。 解题报告 如果一条边要得到价值，那么这条边的两端必须选，这就是闭合图的要求。所以我们把每条边也当成点，然后建图，刷最大权闭合图就行了。 示例程序 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;const int maxn=55000,maxm=155000,MAXINT=((1&lt;&lt;30)-1)*2+1;int n,m,ans,E,lnk[maxn+5],son[(maxm&lt;&lt;1)+5],nxt[(maxm&lt;&lt;1)+5];int cur[maxn+5],que[maxn+5],ti,vis[maxn+5],dis[maxn+5];pair&lt;int,int&gt; e[(maxm&lt;&lt;1)+5];inline void Add(int x,int y,int z)&#123; son[E]=y;nxt[E]=lnk[x];e[E]=mp(0,z);lnk[x]=E++; son[E]=x;nxt[E]=lnk[y];e[E]=mp(0,0);lnk[y]=E++;&#125;inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;ti++;que[++Tail]=s;vis[s]=ti;dis[s]=0; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;e[j].fr&lt;e[j].sc) que[++Tail]=u,vis[u]=ti,dis[u]=dis[x]+1; return vis[t]==ti;&#125;int Dfs(int x,int gl,int MIN=MAXINT)&#123; if (x==gl||!MIN) return MIN;int f=0,now; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;(now=Dfs(son[j],gl,min(MIN,e[j].sc-e[j].fr))))&#123; f+=now;e[j].fr+=now;e[j^1].fr-=now; if (!(MIN-=now)) break; &#125; return f;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m);E=0;memset(lnk,255,sizeof(lnk)); for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),Add(i,n+m+1,x); for (int i=1,x,y,z;i&lt;=m;i++,ans+=z) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),Add(0,n+i,z),Add(n+i,x,MAXINT),Add(n+i,y,MAXINT); while (Bfs(0,n+m+1)) memcpy(cur,lnk,sizeof(lnk)),ans-=Dfs(0,n+m+1); return printf(\"%d\\n\",ans),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"}],"author":"ZigZagK"},{"title":"最小割模型","slug":"MinCutModel","date":"2018-03-08T12:14:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/08/MinCutModel/","link":"","permalink":"https://zigzagk.github.io/2018/03/08/MinCutModel/","excerpt":"对《最小割模型在信息学竞赛中的应用》的一些口胡QAQ。","text":"对《最小割模型在信息学竞赛中的应用》的一些口胡QAQ。 分数规划 (01)分数规划为下面一些问题作准备……基本上都是二分答案的套路。 分数规划+最小割：ZOJ2676 最大权闭合图 给出一张带点权的有向图，你可以选出一些点，如果这些点中任意一个点连接到的点均在选出的点中，则称这张图是闭合图，得到的价值是选出的点的点权之和，求最大权闭合图。 我们可以这样搞：如果 \\(x\\) 的点权 \\(w_x&gt;0\\) ，就建 \\((S,x,w_x)\\) 的边，否则建 \\((x,T,-w_x)\\) 的边，然后这张图中的边 \\((u,v)\\) 就建 \\((u,v,+\\infty)\\) 。则最后的答案是： \\[ (\\sum_{w_x&gt;0}w_x)-MinCut(S,T) \\] 为什么啊……假设选出的点集是 \\(V_1(S\\in V_1)​\\) ，没选的点集是 \\(V_2(T\\in V_2)​\\) ，用 \\(V^-,V^+​\\) 表示 \\(V​\\) 集合中点权为负和点权为正的点。由于要求割，\\(V_1​\\) 和 \\(V_2​\\) 之间不能有任何边相连，所以： \\[ (\\sum_{w_x&gt;0}w_x)-MinCut(S,T)=(\\sum_{x\\in V_1^+}w_x)+(\\sum_{x\\in V_2^+}w_x)-[(\\sum_{x\\in V_2^+}w_x)-(\\sum_{x\\in V_1^-}w_x)]\\\\ ans=w(V_1)=(\\sum_{x\\in V_1^-}w_x)+(\\sum_{x\\in V_1^+}w_x) \\] 上下相等啊，所以答案就是所有正权减去最小割。 最大权闭合图经典模型：BZOJ1497 最大权闭合图：BZOJ4873 最大密度子图 给出一张 \\(n\\) 个点 \\(m\\) 条边的无向图，你可以选出一些点 \\(V&#39;\\) ，定义一种方案的密度为： \\[ {|E&#39;|\\over |V&#39;|},E&#39;=\\{(u,v)|u\\in V,v\\in V,(u,v)\\in E\\} \\] 求最大密度子图。 明显是01分数规划，所以先二分答案 \\(mid\\) ，那么就是验证 \\(|E&#39;|-|V&#39;|mid\\ge 0\\) 。一种比较直接的方法就是令每个点的点权为 \\(-g\\) ，每条边的边权为 \\(1\\) ，因为一条边被选说明两个点都被选了，所以转化为了最大权闭合图。 这样点数和边数都是 \\(n+m\\) ，因为二分精度为 \\(1\\over n^2\\) 即二分次数为 \\(O(log_2{m-{1\\over n}\\over{1\\over n^2}})=O(log_2n)\\) ，所以时间复杂度为 \\(O(log_2n\\cdot Mincut(n+m,n+m))\\) 。可能会炸啊，所以接下来说一种更好的算法： 最大化 \\(|E&#39;|-|V&#39;|mid\\Leftrightarrow\\) 最小化 \\(|V&#39;|mid-|E&#39;|\\) ，我们可以把 \\(|E&#39;|\\) 转化为 \\(|V&#39;|\\) 的导出子图删去连出去的边，写出表达式就变成了这样子( \\(\\overline{V&#39;}\\) 表示 \\(V-V&#39;\\) ，\\(d_x\\) 表示 \\(x\\) 的度数，\\(c(V&#39;,\\overline{V&#39;})\\) 表示连出去的边的数量)： \\[ \\begin{align} |V&#39;|mid-|E&#39;| &amp;= |V&#39;|mid-{\\sum_{x\\in V&#39;}d_x-c(V,\\overline{V&#39;})\\over2}\\\\ &amp;={1\\over 2}[(\\sum_{u\\in V&#39;}2mid-d_u)-c(V,\\overline{V&#39;})] \\end{align} \\] 如果我们把 \\(2mid-d_u\\) 当做 \\(u\\) 的点权，那么我们可以这么建图： \\(s\\to u:0|(u,v):1|u\\to t:2mid-d_u\\) 感性理解：切断 \\((u,v)\\) 或者选择 \\(u\\) 都需要花费，那么最小花费就是最小割。 然后求出最小割就是答案了？？？这图怎么这么奇怪啊？实际上因为 \\(2mid-d_u\\) 会爆负，所以我们给辅助边加上 \\(U\\) 防止爆负（ \\(U\\) 取 \\(m\\) 即可），然后再求最小割。 可是加了 \\(m\\) 之后最小割就不表示上面那个验证式子了。我们推一下： \\[ \\begin{align} c[S,T]&amp;=\\sum_{ u\\in \\overline{V&#39;} }c_{ s,u }+\\sum_{ u\\in V&#39; }c_{ u,t }+\\sum_{ u\\in V&#39;,v\\in \\overline{ V&#39; },(u,v)\\in E}c_{ u,v }\\\\ &amp;=U|\\overline{ V&#39; }|+\\sum_{u\\in V&#39;}(U+2mid-d_u+\\sum_{v\\in \\overline{V&#39;},(u,v)\\in E}1)\\\\ &amp;=U|V|+\\sum_{u\\in V&#39;}(2mid-d_u+d_u-\\sum_{v\\in V&#39;,(u,v)\\in E}1)\\\\ &amp;=U|V|+\\sum_{u\\in V&#39;}(2mid-\\sum_{v\\in V&#39;,(u,v)\\in E}1)\\\\ &amp;=U|V|+2mid|V&#39;|-2|E&#39;|\\\\ &amp;=Un-2(|E&#39;|-mid|V&#39;|) \\end{align}\\\\ \\Updownarrow\\\\ |E&#39;|-mid|V&#39;|={Un-c[S,T]\\over 2} \\] 所以只要求出最小割 \\(c[S,T]\\) ，然后验证 \\(Un-c[S,T]\\ge 0\\) 就行了。但是要注意一个细节，这么建图我们可以发现能够从 \\(s\\) 遍历到的点就是被选的点，而最大密度子图是不允许不选( \\(c[S,T]=Un\\) )的，所以验证条件应该为 \\(Un-c[S,T]&gt;0\\) 。 这样点数为 \\(O(n)\\) ，边数为 \\(O(n+m)=O(m)\\) ，达到了下界。 最大密度子图：POJ3155 最大密度子图(边权&amp;点权) 还是套用上述模型，令点权为 \\(p_u\\) 边权为 \\(w_e\\) ，那么二分枚举 \\(mid\\) 之后，点权变成了 \\(2mid-2p_u-d_u\\) ( \\(d_u\\) 定义为与 \\(u\\) 相连的边的权值和)，边权从 \\(1\\) 变成了 \\(w_x\\) ，所以这么建图： \\(s\\to u:0|(u,v)=w_e|(u\\to t):2mid-2p_u-d_u\\) (ps：\\(2mid-2p_u-d_u\\) 是新点权，有些题目可能直接就推出新点权了，反正分析对就行了QAQ) 还是可以得到：验证函数 \\(={Un-c[S,T]\\over 2}\\) ，所以和之前一样判断就行了。 但是二分范围和精度还有 \\(U\\) 的范围都需要变化，根据题意分析即可。 带边权点权的最大密度子图：计蒜客15549","categories":[{"name":"Knowledge","slug":"Knowledge","permalink":"https://zigzagk.github.io/categories/Knowledge/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"}],"author":"ZigZagK"},{"title":"[贪心+线性基]BZOJ2460(BeiJing2011)【元素】题解","slug":"BZOJ2460","date":"2018-03-07T11:35:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/07/BZOJ2460/","link":"","permalink":"https://zigzagk.github.io/2018/03/07/BZOJ2460/","excerpt":"题目概述 有 \\(n\\) 种无数个的物品，每种物品带有ZZK的蒟蒻值 \\(weak_i\\) 和JZ的神犇值 \\(strong_i\\) ，你现在可以选任意个物品，将得到所有物品神犇值之和的JZ神犇值。但是ZZK实在是太弱了，如果你选的物品中能够挑出一个非空真子集使得蒟蒻值异或和为 \\(0\\) ，就会抵消所有JZ的神犇值！求你能得到最大的神犇值。","text":"题目概述 有 \\(n\\) 种无数个的物品，每种物品带有ZZK的蒟蒻值 \\(weak_i\\) 和JZ的神犇值 \\(strong_i\\) ，你现在可以选任意个物品，将得到所有物品神犇值之和的JZ神犇值。但是ZZK实在是太弱了，如果你选的物品中能够挑出一个非空真子集使得蒟蒻值异或和为 \\(0\\) ，就会抵消所有JZ的神犇值！求你能得到最大的神犇值。 解题报告 选的物品中没有非空子集异或和为 \\(0\\) 说明这是一组基，所以我们可以贪心，先把物品按照神犇值从大到小排序，然后能插入就插入就行了。 示例程序 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fr first#define sc secondusing namespace std;typedef long long LL;const int maxn=1000,Log=60;int n,ans;LL M[Log+5];pair&lt;int,LL&gt; a[maxn+5];inline bool cmp(pair&lt;int,LL&gt; a,pair&lt;int,LL&gt; b) &#123;return a&gt;b;&#125;inline bool Insert(LL x)&#123; for (int j=Log;~j;j--) if (x&gt;&gt;j&amp;1) if (M[j]) x^=M[j]; else &#123;M[j]=x;return true;&#125; return false;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); for (int i=(scanf(\"%d\",&amp;n),1);i&lt;=n;i++) scanf(\"%lld%d\",&amp;a[i].sc,&amp;a[i].fr); sort(a+1,a+1+n,cmp); for (int i=1;i&lt;=n;i++) if (Insert(a[i].sc)) ans+=a[i].fr; return printf(\"%d\\n\",ans),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://zigzagk.github.io/tags/贪心/"},{"name":"线性基","slug":"线性基","permalink":"https://zigzagk.github.io/tags/线性基/"}],"author":"ZigZagK"},{"title":"[分数规划+最小割任意方案]ZOJ2676【Network Wars】题解","slug":"ZOJ2676","date":"2018-03-07T10:32:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/07/ZOJ2676/","link":"","permalink":"https://zigzagk.github.io/2018/03/07/ZOJ2676/","excerpt":"题目概述 有一个 \\(n\\) 个点 \\(m\\) 条双向边的图，每条边的边权是 \\(w_i\\) 。JZ为了防止神犇之力外泄，想切断 \\(1\\) 到 \\(n\\) 的连接（切断一条边的代价是这条边的边权）。因为JZ是神犇，边的数量并不能限制他，所以如果选了 \\(k\\) 条总代价为 \\(c\\) 的边，花费是 \\(c\\over k\\) 。求最小花费时的一种可行方案。","text":"题目概述 有一个 \\(n\\) 个点 \\(m\\) 条双向边的图，每条边的边权是 \\(w_i\\) 。JZ为了防止神犇之力外泄，想切断 \\(1\\) 到 \\(n\\) 的连接（切断一条边的代价是这条边的边权）。因为JZ是神犇，边的数量并不能限制他，所以如果选了 \\(k\\) 条总代价为 \\(c\\) 的边，花费是 \\(c\\over k\\) 。求最小花费时的一种可行方案。 解题报告 这是一个01分数规划的问题，所以我们先二分一个答案 \\(mid\\) ，然后用 \\(w_i-mid\\) 作为新边，接下来就转化为了最小割问题，只是要注意到如果一条边小于 \\(0\\) ，则一定会被选。 任意方案怎么求？其实很简单，刷完所有增广路如果一条边的一端能够到达而另一条边不能到达，那么就说明这条边被割了。 示例程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef long double DB;const int maxn=100,maxm=400;int n,m,x[maxm+5],y[maxm+5],z[maxm+5];int E,lnk[maxn+5],son[(maxm&lt;&lt;2)+5],nxt[(maxm&lt;&lt;2)+5];int ti,cur[maxn+5],vis[maxn+5],dis[maxn+5],que[maxn+5];int ans[maxm+5];pair&lt;DB,DB&gt; e[(maxm&lt;&lt;2)+5];inline int fcmp(DB a,DB b) &#123;if (fabs(a-b)&lt;1e-8) return 0;if (a&lt;b) return -1;return 1;&#125;inline void Add(int x,int y,DB z)&#123; son[E]=y;nxt[E]=lnk[x];e[E]=mp(0,z);lnk[x]=E++; son[E]=x;nxt[E]=lnk[y];e[E]=mp(0,0);lnk[y]=E++; son[E]=x;nxt[E]=lnk[y];e[E]=mp(0,z);lnk[y]=E++; son[E]=y;nxt[E]=lnk[x];e[E]=mp(0,0);lnk[x]=E++;&#125;inline bool Bfs(int s,int t)&#123; int Head=0,Tail=0;ti++;que[++Tail]=s;vis[s]=ti;dis[s]=0; while (Head!=Tail) for (int x=que[++Head],j=lnk[x],u;~j;j=nxt[j]) if (vis[u=son[j]]&lt;ti&amp;&amp;fcmp(e[j].fr,e[j].sc)&lt;0) que[++Tail]=u,vis[u]=ti,dis[u]=dis[x]+1; return vis[t]==ti;&#125;DB Dfs(int x,int gl,DB MIN=1e100)&#123; if (x==gl||!fcmp(MIN,0)) return MIN;DB f=0,now; for (int &amp;j=cur[x];~j;j=nxt[j]) if (dis[x]+1==dis[son[j]]&amp;&amp;fcmp(now=Dfs(son[j],gl,min(MIN,e[j].sc-e[j].fr)),0))&#123; f+=now;e[j].fr+=now;e[j^1].fr-=now; if (!fcmp(MIN-=now,0)) break; &#125; return f;&#125;inline bool check(DB mid)&#123; DB ans=0;E=0;memset(lnk,255,sizeof(lnk)); for (int i=1;i&lt;=m;i++) if (fcmp(z[i],mid)&gt;0) Add(x[i],y[i],z[i]-mid); else ans+=z[i]-mid; while (Bfs(1,n)) memcpy(cur,lnk,sizeof(lnk)),ans+=Dfs(1,n); return fcmp(ans,0)&lt;=0;&#125;inline void PrintEdge(DB mid,int s)&#123; E=0;memset(lnk,255,sizeof(lnk));ans[0]=0; for (int i=1;i&lt;=m;i++) if (fcmp(z[i],mid)&gt;0) Add(x[i],y[i],z[i]-mid); while (Bfs(1,n)) memcpy(cur,lnk,sizeof(lnk)),Dfs(1,n); for (int i=1;i&lt;=m;i++) if (vis[x[i]]&lt;ti&amp;&amp;vis[y[i]]==ti||vis[y[i]]&lt;ti&amp;&amp;vis[x[i]]==ti||fcmp(z[i],mid)&lt;=0) ans[++ans[0]]=i; printf(\"%d\\n\",ans[0]);for (int i=1;i&lt;=ans[0];i++) &#123;if (i&gt;1) putchar(' ');printf(\"%d\",ans[i]);&#125;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); while (~scanf(\"%d%d\",&amp;n,&amp;m))&#123; for (int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;x[i],&amp;y[i],&amp;z[i]); DB ans=1e100; for (int i=1,L=0,R=1e9;i&lt;=n;i++,L=0,R=1e9)&#123; for (int mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) check((DB)mid/i)?R=mid-1:L=mid+1; if (fcmp((DB)L/i,ans)&lt;0) ans=(DB)L/i; &#125; PrintEdge(ans,1);puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"ZOJ","slug":"Online-Judge/ZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/ZOJ/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://zigzagk.github.io/tags/网络流/"},{"name":"分数规划","slug":"分数规划","permalink":"https://zigzagk.github.io/tags/分数规划/"}],"author":"ZigZagK"},{"title":"[Tarjan+树形背包]BZOJ2427(HAOI2010)【软件安装】题解","slug":"BZOJ2427","date":"2018-03-05T05:56:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/03/05/BZOJ2427/","link":"","permalink":"https://zigzagk.github.io/2018/03/05/BZOJ2427/","excerpt":"题目概述 有 \\(n\\) 个软件和 \\(m\\) 的容量，每个软件需要 \\(w_i\\) 的容量，有 \\(v_i\\) 的价值，同时依赖 \\(d_i\\) 软件( \\(d_i=0\\) 则没有依赖)。问最大的价值。","text":"题目概述 有 \\(n\\) 个软件和 \\(m\\) 的容量，每个软件需要 \\(w_i\\) 的容量，有 \\(v_i\\) 的价值，同时依赖 \\(d_i\\) 软件( \\(d_i=0\\) 则没有依赖)。问最大的价值。 解题报告 这是道假题，软件可以认为是瞬间安装，所以互相依赖的多个软件可以同时安装。 那么也就是给出一张带环图，我们先把强连通分量缩点，然后就变成了森林，接下来刷树形分组背包就行了。 ps：我太naive了，以为树中不会出现强连通分量，然后就0sWA了10多次。 示例程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;const int maxn=100,maxm=500;int n,m,w[maxn+5],v[maxn+5],D[maxn+5],g[maxn+5][maxm+5];int E,lnk[2][maxn+5],son[(maxn&lt;&lt;1)+5],nxt[(maxn&lt;&lt;1)+5];int ti,dfn[maxn+5],low[maxn+5],top,stk[maxn+5],fa[maxn+5];int sum[maxn+5],val[maxn+5],si[maxn+5];bool instk[maxn+5];int tot;pair&lt;int,int&gt; e[maxn+5];#define Add(ID,x,y) son[++E]=(y),nxt[E]=lnk[ID][x],lnk[ID][x]=Evoid Tarjan(int x)&#123; dfn[x]=low[x]=++ti;stk[++top]=x;instk[x]=true; for (int j=lnk[0][x];j;j=nxt[j]) if (!dfn[son[j]]) Tarjan(son[j]),low[x]=min(low[x],low[son[j]]); else if (instk[son[j]]) low[x]=min(low[x],dfn[son[j]]); if (dfn[x]==low[x]) for (int y=stk[top--];;y=stk[top--]) &#123;fa[y]=x;sum[x]+=w[y];val[x]+=v[y];si[x]++;instk[y]=false;if (x==y) break;&#125;&#125;void DP(int x)&#123; if (sum[x]&gt;m) return; for (int e=lnk[1][x];e;e=nxt[e])&#123; DP(son[e]); for (int j=m-sum[x];~j;j--) for (int i=j;~i;i--) g[x][j]=max(g[x][j],g[x][j-i]+g[son[e]][i]); &#125; for (int j=m;j&gt;=sum[x];j--) g[x][j]=g[x][j-sum[x]]+val[x];for (int j=0;j&lt;sum[x];j++) g[x][j]=0;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;v[i]); for (int i=1,x;i&lt;=n;i++) &#123;scanf(\"%d\",&amp;x);if (x) Add(0,x,i);&#125; for (int i=1;i&lt;=n;i++) if (!dfn[i]) Tarjan(i); for (int i=1;i&lt;=n;i++) for (int j=lnk[0][i];j;j=nxt[j]) if (fa[i]!=fa[son[j]]) e[++tot]=mp(fa[i],fa[son[j]]); sort(e+1,e+1+tot);tot=unique(e+1,e+1+tot)-e-1; for (int i=1;i&lt;=tot;i++) Add(1,e[i].fr,e[i].sc),D[e[i].sc]=1; for (int i=1;i&lt;=n;i++) if (fa[i]==i&amp;&amp;!D[i]) Add(1,0,i);DP(0); return printf(\"%d\\n\",g[0][m]),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"强连通分量","slug":"强连通分量","permalink":"https://zigzagk.github.io/tags/强连通分量/"},{"name":"背包","slug":"背包","permalink":"https://zigzagk.github.io/tags/背包/"}],"author":"ZigZagK"},{"title":"[裴蜀定理]BZOJ2299(HAOI2011)【向量】题解","slug":"BZOJ2299","date":"2018-02-28T08:25:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/02/28/BZOJ2299/","link":"","permalink":"https://zigzagk.github.io/2018/02/28/BZOJ2299/","excerpt":"题目概述 问能否用任意个向量 \\((\\pm a,\\pm b)\\) 和 \\((\\pm b,\\pm a)\\) 组合出向量 \\((x,y)\\) 。","text":"题目概述 问能否用任意个向量 \\((\\pm a,\\pm b)\\) 和 \\((\\pm b,\\pm a)\\) 组合出向量 \\((x,y)\\) 。 解题报告 显然只有这么几种方法： \\(x\\pm 2a,x\\pm 2b,y\\pm 2a,y\\pm 2b\\) \\(x+a且y+b,x+b且y+a\\) 而且后两种方法至多用一次（用多次等价于上面的方法）。 所以暴枚后面两种方法是否使用，然后就是判断： \\(2f_1a+2f_2b=x\\) \\(2g_1a+2g_2b=y\\) 这就是扩展欧几里得判断是否有解的问题，所以用裴蜀定理就行了。 示例程序 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int te;LL a,b,x,y,r;inline void Abs(LL &amp;x) &#123;if (x&lt;0) x=-x;&#125;LL gcd(LL a,LL b) &#123;if (!b) return a;return gcd(b,a%b);&#125;inline bool check(LL x,LL y) &#123;return !(x%r)&amp;&amp;!(y%r);&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); for (scanf(\"%d\",&amp;te);te;te--)&#123; scanf(\"%lld%lld%lld%lld\",&amp;a,&amp;b,&amp;x,&amp;y); if (!a&amp;&amp;!b) &#123;puts((!x&amp;&amp;!y)?\"Y\":\"N\");continue;&#125; Abs(a);Abs(b);Abs(x);Abs(y);if (a&gt;b) swap(a,b),swap(x,y);r=gcd(a&lt;&lt;1,b&lt;&lt;1); puts(check(x,y)||check(x+a,y+b)||check(x+b,y+a)||check(x+a+b,y+a+b)?\"Y\":\"N\"); &#125; return 0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"exgcd","slug":"exgcd","permalink":"https://zigzagk.github.io/tags/exgcd/"}],"author":"ZigZagK"},{"title":"[树状数组]BZOJ3192(JLOI2013)【删除物品】题解","slug":"BZOJ3192","date":"2018-02-26T07:39:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/02/26/BZOJ3192/","link":"","permalink":"https://zigzagk.github.io/2018/02/26/BZOJ3192/","excerpt":"题目概述 一共有两堆物品，分别有 \\(n\\) 个和 \\(m\\) 个。所有物品都是一样的，但是它们有不同的优先级。只能够移动某堆中位于顶端的物品，你可以把任意一堆中位于顶端的物品移动到另外一堆的顶端。若此物品是当前所有物品中优先级最高的，可以直接将之删除而不用移动。求出将所有物品删除所需的最小步数。删除操作不计入步数之中。","text":"题目概述 一共有两堆物品，分别有 \\(n\\) 个和 \\(m\\) 个。所有物品都是一样的，但是它们有不同的优先级。只能够移动某堆中位于顶端的物品，你可以把任意一堆中位于顶端的物品移动到另外一堆的顶端。若此物品是当前所有物品中优先级最高的，可以直接将之删除而不用移动。求出将所有物品删除所需的最小步数。删除操作不计入步数之中。 解题报告 因为只有两堆，所以移动操作是固定的，可以用两个Splay来维护，这道题就解决了…… 然而写两个要求排名的Splay简直就是有毒，我们可以再探究一下移动的性质： 123451 2 2 7X 5X 44 7 1 3 15 3 -&gt; 4 -&gt; 2 -&gt; ... 5 7X 3 我们发现如果不把删除的物品移出物品堆，那么实际上只有一个分开两堆的指针在移动： 125 4 1 2 7 3 -&gt; 5 4 1 2 7X 3 -&gt; 5X 4 1 2 7 3 -&gt; ... ^ ^ ^ 那么原问题就变成一个区间查询问题，注意一下新指针在左和右两种情况就行了。 示例程序 被绕晕了……这么点代码竟然写了很久QAQ…… 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100000;int n,m,a[maxn+5],c[maxn+5],pos[maxn+5];LL ans;inline bool cmp(int A,int B) &#123;return a[A]&gt;a[B];&#125;inline void Update(int x,int tem) &#123;for (int i=x;i&lt;=n+m;i+=i&amp;-i) c[i]+=tem;&#125;inline int Sum(int x) &#123;int sum=0;for (int i=x;i;i-=i&amp;-i) sum+=c[i];return sum;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for (int i=n;i&gt;=1;i--) scanf(\"%d\",&amp;a[i]),Update(i,1),pos[i]=i; for (int i=n+1;i&lt;=n+m;i++) scanf(\"%d\",&amp;a[i]),Update(i,1),pos[i]=i; int lst=n;sort(pos+1,pos+1+n+m,cmp); for (int i=1;i&lt;=n+m;Update(pos[i++],-1)) if (lst&lt;pos[i]) ans+=Sum(pos[i]-1)-Sum(lst),lst=pos[i]-1; else ans+=Sum(lst)-Sum(pos[i]),lst=pos[i]; return printf(\"%lld\\n\",ans),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://zigzagk.github.io/tags/树状数组/"}]},{"title":"[Top]BZOJ刷题记录（施工到AFO）","slug":"BZOJSolution","date":"2018-02-24T11:52:00.000Z","updated":"2019-07-25T05:30:10.937Z","comments":true,"path":"2018/02/24/BZOJSolution/","link":"","permalink":"https://zigzagk.github.io/2018/02/24/BZOJSolution/","excerpt":"QAQ，我要努力200题！","text":"QAQ，我要努力200题！ 题号 日期 题解 备注 BZOJ3144 2018.4.11 QwQ BZOJ4310 2018.4.11 QwQ BZOJ2369 2018.4.2 QwQ BZOJ1566 2018.3.29 QwQ BZOJ1797 2018.3.12 QwQ BZOJ2435 2018.3.11 Dfs就好了？！ BZOJ4873 2018.3.10 QwQ BZOJ1497 2018.3.8 QwQ BZOJ2460 2018.3.7 QwQ BZOJ2427 2018.3.5 QwQ BZOJ4998 2018.3.4 LCT+并查集 BZOJ2957弱化版 BZOJ4033 2018.2.28 QwQ BZOJ3192 2018.2.26 QwQ BZOJ2423 2018.2.24 QwQ BZOJ1048 2018.2.20 QwQ BZOJ1862 2018.2.20 同上一题 双倍经验1056 BZOJ1056 2018.2.20 平衡树裸题 双倍经验1862 BZOJ1060 2018.2.19 QwQ BZOJ1052 2018.2.18 QwQ BZOJ2429 2018.2.11 最小瓶颈生成树。 BZOJ2298 2018.2.11 QwQ BZOJ2751 2018.2.10 答案 \\((1+2+3+\\cdots+n)^m\\) ，每个位置减一下限制就行了。 BZOJ1055 2018.2.10 QwQ BZOJ2748 2018.2.7 01背包裸题，交Pascal没注意，成功CE BZOJ1046 2018.2.6 QwQ BZOJ1045 2018.2.5 QwQ BZOJ1044 2018.2.4 QwQ BZOJ5084 2018.2.3 QwQ BZOJ2959 2018.1.17 QwQ BZOJ4589 2018.1.15 QwQ FWT BZOJ2957 2018.1.12 QwQ BZOJ4916 2018.1.9 QwQ BZOJ3771 2018.1.9 QwQ 母函数+FFT BZOJ2242 2018.1.8 复习复习……Power+Exgcd+BSGS。 BZOJ1028 2018.1.8 爆枚答案，爆枚对子，组成刻子，检查顺子。 BZOJ1367 2018.1.8 QwQ BZOJ2555 2018.1.8 QwQ 码农数据结构题 BZOJ4530 2018.1.6 QwQ LCT维护子树信息 BZOJ4817 2018.1.5 QwQ BZOJ2843 2018.1.4 QwQ BZOJ2049 2018.1.4 QwQ BZOJ3527 2018.1.3 QwQ FFT求卷积 BZOJ3676 2017.12.31 QwQ 祝大家元旦快乐啦^o^/ BZOJ3600 2017.12.31 QwQ 动态标号 BZOJ3944 2017.12.26 假装做了新题……这题+这题 杜教筛 BZOJ2286 2017.12.24 QwQ 虚树 BZOJ3884 2017.12.21 QwQ BZOJ2154 2017.12.21 QwQ BZOJ2820 2017.12.20 QwQ BZOJ4552 2017.12.19 QwQ 非常规二分题 BZOJ4515 2017.12.17 QwQ 有毒数据结构题，入坑谨慎 BZOJ1922 2017.12.14 QwQ 比较妙的Dijkstra BZOJ2783 2017.12.12 DFS然后用set就可以水过这题QAQ BZOJ4518 2017.12.11 把 \\(m^2\\) 乘进答案中，就变成斜率优化模板题了 BZOJ3165 2017.12.10 QwQ 李超线段树裸题 BZOJ2705 2017.12.10 QwQ BZOJ2301 2017.12.9 QwQ BZOJ2440 2017.12.9 QwQ 结论 BZOJ4010 2017.12.5 QwQ 很妙的拓扑 BZOJ1054 2017.12.5 \\(16\\) 个格子，直接BFS BZOJ1024 2017.12.5 QwQ BZOJ3668 2017.12.5 QwQ 经典题，进阶版是BZOJ4811 BZOJ3689 2017.12.3 QwQ 好妙的最小割 BZOJ1121 2017.12.3 因为光路可逆，所以答案就是 \\(n\\div 2\\) …… 被学长用作娱乐气氛题 BZOJ1218 2017.12.3 直接容斥 BZOJ1800 2017.12.3 答案是 \\(直径数\\choose 2\\) ，但我打了 \\(O(n^4)\\) 大暴力…… BZOJ1058 2017.12.3 QwQ BZOJ3505 2017.12.3 QwQ 显然的结论 BZOJ2431 2017.12.3 简单的前缀和优化递推","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}]},{"title":"欢迎来到ZigZagK的博客！","slug":"ZigZagKBlog","date":"2018-02-24T07:26:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2018/02/24/ZigZagKBlog/","link":"","permalink":"https://zigzagk.github.io/2018/02/24/ZigZagKBlog/","excerpt":"博主是个蒟蒻！谢谢Dalao们捧场！","text":"博主是个蒟蒻！谢谢Dalao们捧场！ 是时候丢弃CSDN了。——By Lynstery 其实我也是被CSDN气过来的。 \\(\\LaTeX\\) :我们来求个 \\(LIS\\) 吧 \\(f(i)=max\\{f(j)|j&lt;i,a_j&lt;a_i\\}+1\\) \\[ 我有一个数组\\{A_n\\}\\\\ A_1,A_2,A_3,A_4,A_5,A_6,A_7,\\cdots,A_n\\\\ A_i的平方是A_i^2,A_i开根号是\\sqrt{A_i} \\] 话说，如果每次换电脑都要重装Hexo什么的，好像很烦啊。 1int main() &#123;return 0;&#125; 人名 OI水平 文化课水平 ZigZagK \\(-\\infty\\) \\(-\\infty\\) Lynstery \\(+\\infty\\) \\(+\\infty\\) 这是我CSDN的博客链接。 我的Logo:","categories":[{"name":"杂","slug":"杂","permalink":"https://zigzagk.github.io/categories/杂/"},{"name":"Hexo","slug":"杂/Hexo","permalink":"https://zigzagk.github.io/categories/杂/Hexo/"}],"tags":[{"name":"自己的理解","slug":"自己的理解","permalink":"https://zigzagk.github.io/tags/自己的理解/"}]},{"title":"[wqs二分+最小生成树]BZOJ2654【tree】题解","slug":"BZOJ2654","date":"2017-10-30T06:24:00.000Z","updated":"2018-04-29T17:36:31.000Z","comments":true,"path":"2017/10/30/BZOJ2654/","link":"","permalink":"https://zigzagk.github.io/2017/10/30/BZOJ2654/","excerpt":"题目概述 给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 \\(K\\) 条白色边的生成树。","text":"题目概述 给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 \\(K\\) 条白色边的生成树。 解题报告 可怕的题目……首先我们可以先求出一棵最小生成树，但是不一定满足 \\(K\\) 条白色边。 这怎么办呢？容易想到提高（降低）白色边的优先级，从而多选（少选）白色边。 于是我们可以将白色边的边权全加上 \\(mid\\) （这样白色边之间的优先级保持不变），然后重新求最小生成树，如果满足要求说明 \\(mid\\) 可行。而由于 \\(mid\\) 对白色边的影响是单调的，所以可以二分。 还需要注意，Kruskal对边排序时，应该双关键字排序（白色边比边权相同的黑色边优先）。 2018.3.15UPD：这其实就是wqs二分。 示例程序 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define fr first#define sc secondusing namespace std;typedef pair&lt; pair&lt;int,int&gt;,pair&lt;int,int&gt; &gt; Edge;const int maxn=50000,maxe=100000;int n,m,K;Edge e[maxe+5];int father[maxn+5],now,ans;#define val(e) (e.sc.fr+now*(e.sc.sc^1))inline bool cmp(Edge a,Edge b) &#123;return val(a)&lt;val(b)||val(a)==val(b)&amp;&amp;a.sc.sc&lt;b.sc.sc;&#125;int getfa(int x) &#123;if (father[x]==x) return x;return father[x]=getfa(father[x]);&#125;inline bool check(int mid)&#123; int tot=0;ans=0;now=mid;for (int i=0;i&lt;n;i++) father[i]=i;sort(e+1,e+1+m,cmp); for (int i=1;i&lt;=m;i++) &#123; int fx=getfa(e[i].fr.fr),fy=getfa(e[i].fr.sc);if (fx==fy) continue; ans+=val(e[i]);tot+=!e[i].sc.sc;father[fx]=fy; &#125; return tot&gt;=K;&#125;int main()&#123; freopen(\"program.in\",\"r\",stdin); freopen(\"program.out\",\"w\",stdout); scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;K); for (int i=1;i&lt;=m;i++) scanf(\"%d%d%d%d\",&amp;e[i].fr.fr,&amp;e[i].fr.sc,&amp;e[i].sc.fr,&amp;e[i].sc.sc); int L=-105,R=105; for (int mid=L+(R-L&gt;&gt;1);L&lt;=R;mid=L+(R-L&gt;&gt;1)) if (check(mid)) L=mid+1; else R=mid-1; return check(R),printf(\"%d\\n\",ans-R*K),0;&#125;","categories":[{"name":"Online Judge","slug":"Online-Judge","permalink":"https://zigzagk.github.io/categories/Online-Judge/"},{"name":"BZOJ","slug":"Online-Judge/BZOJ","permalink":"https://zigzagk.github.io/categories/Online-Judge/BZOJ/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://zigzagk.github.io/tags/二分/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://zigzagk.github.io/tags/最小生成树/"}]}]}